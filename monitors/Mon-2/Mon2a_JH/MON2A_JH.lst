---------------------------------------------
Z80 ASSEMBLER LISTING
Line   Addr Opcode      Label   Instruction
---------------------------------------------
0001   0000             ;***************************************
0002   0000             ;*   MON2 for TEC-1 and compatibles    *
0003   0000             ;***************************************
0004   0000             ; Version A
0005   0000             ; Written by Ken Stone
0006   0000             ; Decompiled by John Hardy
0007   0000             ; Commented and optimised by Mark Jelic
0008   0000             
0009   0000             ;Keyboard functions:
0010   0000             ;Shift-Insert range 0900 - 4000 (03FF??)
0011   0000             ;Shift-Delete range 0900 - 03FF (03FF is set to 00 on use of delete function).
0012   0000             ;Shift-Address jumps to location stored at 08D2 and 08D3
0013   0000             ;
0014   0000             ;Info:
0015   0000             ;Stack Start 08C0
0016   0000             ;Stack Max Length C0
0017   0000             ;User Code Start 0900
0018   0000             ;KeyData location 08E0 (placed there by NMI routine)
0019   0000             
0020   0000             STACKSTART:     EQU $08C0               ; Stack Max Length C0
0021   0000             VECTOR0:        EQU $08C0               ; user vector 0
0022   0000             VECTOR1:        EQU $08C2               ; user vector 1
0023   0000             VECTOR2:        EQU $08C4               ; user vector 2
0024   0000             VECTOR3:        EQU $08C6               ; user vector 3
0025   0000             VECTOR4:        EQU $08C8               ; user vector 4
0026   0000             VECTOR5:        EQU $08CA               ; user vector 5
0027   0000             VECTOR6:        EQU $08CC               ; Temporary holder of current address?
0028   0000             SHIFTINS:       EQU $08D2
0029   0000             SHIFTDEL:       EQU $08D4
0030   0000             TUNEADDR:       EQU $08D6
0031   0000             ADDRESS1:       EQU $08D8               ; current ADDRESS in nibbles over 4 bytes
0032   0000             ADDRESS2:       EQU $08D9               ; current ADDRESS - nibble #2
0033   0000             ADDRESS3:       EQU $08DA               ; current ADDRESS - nibble #3
0034   0000             ADDRESS4:       EQU $08DB               ; current ADDRESS - nibble #4
0035   0000             DATA1:          EQU $08DC               ; Current DATA in nibbles over two bytes
0036   0000             DATA2:          EQU $08DD               ; Current DATA - second nibble
0037   0000             MODE:           EQU $08DF               ; Monitor mode (0 = Address Mode, 1 = Data Mode)
0038   0000             KEYDATA:        EQU $08E0               ; Key data location updated by NMI routine
0039   0000             X3:             EQU $08E1
0040   0000             RAMSTART:       EQU $0900               ; User Code Start 0900
0041   0000             
0042   0000             
0043   0000             STARTROM:       .ORG $0000
0044   0000 C3 00 02    RESTART00:      jp STARTMON		         ; Jump to STARTMON @ $0200
0045   0003 FF                          db $FF
0046   0004 FF                          db $FF
0047   0005 FF                          db $FF
0048   0006 FF                          db $FF
0049   0007 FF                          db $FF
0050   0008 2A C0 08    RESTART08:      ld hl,(VECTOR0)          ;jump to vector stored at $08c0
0051   000B E9                          jp (hl)
0052   000C FF                          db $FF
0053   000D FF                          db $FF
0054   000E FF                          db $FF
0055   000F FF                          db $FF
0056   0010 2A C2 08    RESTART10:      ld hl,(VECTOR1)          ;jump to vector stored at $08c2
0057   0013 E9                          jp (hl)
0058   0014 FF                          db $FF
0059   0015 FF                          db $FF
0060   0016 FF                          db $FF
0061   0017 FF                          db $FF
0062   0018 2A C4 08    RESTART18:      ld hl,(VECTOR2)          ;jump to vector stored at $08c4
0063   001B E9                          jp (hl)
0064   001C FF                          db $FF
0065   001D FF                          db $FF
0066   001E FF                          db $FF
0067   001F FF                          db $FF
0068   0020 2A C6 08    RESTART20:      ld hl,(VECTOR3)         ;jump to vector stored at $08c6
0069   0023 E9                          jp (hl)
0070   0024 FF                          db $FF
0071   0025 FF                          db $FF
0072   0026 FF                          db $FF
0073   0027 FF                          db $FF
0074   0028 2A C8 08    RESTART28:      ld hl,(VECTOR4)         ;jump to vector stored at $08c8
0075   002B E9                          jp (hl)
0076   002C FF                          db $FF
0077   002D FF                          db $FF
0078   002E FF                          db $FF
0079   002F FF                          db $FF
0080   0030 2A CA 08    RESTART30:      ld hl,(VECTOR5)         ;jump to vector stored at $08ca
0081   0033 E9                          jp (hl)
0082   0034 FF                          db $FF
0083   0035 FF                          db $FF
0084   0036 FF                          db $FF
0085   0037 FF                          db $FF
0086   0038 2A CC 08    RESTART38:      ld hl,(VECTOR6)         ;jump to vector stored at $08cc
0087   003B E9                          jp (hl)
0088   003C             
0089   003C                             .ORG $066               ;NMI keyboard event
0090   0066 F5          NMINT:          push af                 ;save af ;good idea! fixes Mon1
0091   0067 C5                          push bc                 ;save BC
0092   0068 E5                          push hl                 ;save HL (used in Keyboard Remap)
0093   0069 DB 00                       IN A,($00)              ;a = key port
0094   006B 47                          LD B,A                  ;save A to B
0095   006C CD 20 07                    call KEYREMAP
0096   006F E1                          pop hl                  ;restore hl
0097   0070 C1                          pop bc                  ;restore BC
0098   0071 F1                          pop af                  ;restore af
0099   0072 ED 45                       retn                    ;correct return. fixes Mon1
0100   0074             
0101   0074                             .ORG $0080
0102   0080 EB          SEVSEGDATA:     db $EB                  ; 0
0103   0081 28                          db $28                  ; 1
0104   0082 CD                          db $CD                  ; 2
0105   0083 AD                          db $AD                  ; 3
0106   0084 2E                          db $2E                  ; 4
0107   0085 A7                          db $A7                  ; 5
0108   0086 E7                          db $E7                  ; 6
0109   0087 29                          db $29                  ; 7
0110   0088 EF                          db $EF                  ; 8
0111   0089 2F                          db $2F                  ; 9
0112   008A 6F                          db $6F                  ; A
0113   008B E6                          db $E6                  ; B
0114   008C C3                          db $C3                  ; C
0115   008D EC                          db $EC                  ; D
0116   008E C7                          db $C7                  ; E
0117   008F 47                          db $47                  ; F
0118   0090 E3                          db $E3                  ; G
0119   0091 66                          db $66                  ; H
0120   0092 28                          db $28                  ; I
0121   0093 E8                          db $E8                  ; J
0122   0094 4E                          db $4E                  ; K
0123   0095 C2                          db $C2                  ; L
0124   0096 2D                          db $2D                  ; M
0125   0097 6B                          db $6B                  ; N
0126   0098 EB                          db $EB                  ; O
0127   0099 4F                          db $4F                  ; P
0128   009A 2F                          db $2F                  ; Q
0129   009B 4B                          db $4B                  ; R
0130   009C A7                          db $A7                  ; S
0131   009D 46                          db $46                  ; T
0132   009E EA                          db $EA                  ; U
0133   009F E0                          db $E0                  ; V
0134   00A0 AC                          db $AC                  ; W
0135   00A1 A4                          db $A4                  ; X
0136   00A2 AE                          db $AE                  ; Y
0137   00A3 C9                          db $C9                  ; Z
0138   00A4 10                          db $10                  ; .
0139   00A5 08                          db $08                  ; i
0140   00A6 18                          db $18                  ; !
0141   00A7 04                          db $04                  ; -
0142   00A8 2C                          db $2C                  ;
0143   00A9 00                          db $00                  ; space
0144   00AA 6E                          db $6E                  ; h
0145   00AB CD                          db $CD                  ; Z
0146   00AC FF                          db $FF
0147   00AD FF                          db $FF
0148   00AE FF                          db $FF
0149   00AF FF                          db $FF
0150   00B0             
0151   00B0                             .ORG $00B0
0152   00B0 00          INITADDR:       db $00                  ;0 inital address (start of RAM)
0153   00B1 09                          db $09                  ;9
0154   00B2 00                          db $00                  ;0
0155   00B3 00                          db $00                  ;0
0156   00B4             
0157   00B4                             .ORG $00C0              ; Data table for text message demo.
0158   00C0 1B          DEMOTEXT:       db $1b                  ; R
0159   00C1 18                          db $18                  ; O
0160   00C2 1E                          db $1e                  ; U
0161   00C3 1D                          db $1d                  ; T
0162   00C4 12                          db $12                  ; I
0163   00C5 17                          db $17                  ; N
0164   00C6 0E                          db $0e                  ; E
0165   00C7 29                          db $29                  ; [space]
0166   00C8 0B                          db $0b                  ; B
0167   00C9 22                          db $22                  ; Y
0168   00CA 29                          db $29                  ; [space]
0169   00CB 17                          db $17                  ; N   (Nic. Enots - Ken Stone's old programming pseudonym))
0170   00CC 12                          db $12                  ; I
0171   00CD 0C                          db $0C                  ; C
0172   00CE 24                          db $24                  ; .
0173   00CF 29                          db $29                  ; [space]
0174   00D0 29                          db $29                  ; [space]
0175   00D1 29                          db $29                  ; [space]
0176   00D2 29                          db $29                  ; [space]
0177   00D3 29                          db $29                  ; [space]
0178   00D4 FE                          db $fe                  ; (repeat text)
0179   00D5 1C                          db $1c                  ; STONE  (Text for real surname hidden in code)
0180   00D6 1D                          db $1d
0181   00D7 18                          db $18
0182   00D8 17                          db $17
0183   00D9 0E                          db $0E
0184   00DA FF                          db $ff                  ; (end text)
0185   00DB FF                          db $FF
0186   00DC FF                          db $FF
0187   00DD FF                          db $FF
0188   00DE FF                          db $FF
0189   00DF FF                          db $FF
0190   00E0 CD 5B 02    KEYPLUS:        call GETEDITADDR        ;+ key
0191   00E3 03                          inc bc
0192   00E4 18 04                       jr DATAMODE
0193   00E6 CD 5B 02    KEYMINUS:       call GETEDITADDR        ;- key
0194   00E9 0B                          dec bc
0195   00EA CD 90 04    DATAMODE:       call SETEDITADDR
0196   00ED CD 42 02                    call GETADDRDATA
0197   00F0 21 DF 08                    ld hl,MODE              ; Load HL with the MODE indicator address
0198   00F3 CB C6                       set 0,(hl)              ; Sets bit 0 of the MODE indicator address to 1, indicating it IS in DATA mode
0199   00F5 CB 8E                       res 1,(hl)              ; Sets bit 1 of the MODE indicator address to 0, indicating it is NOT in ADDRESS mode
0200   00F7 C3 72 03                    jp POP_HLAF             ; POPs registers HL and AF and Returns
0201   00FA             
0202   00FA             ; Division table for frequencies starts here
0203   00FA             ; First byte is the Length of the Tone, the second is the Frequency
0204   00FA             ; Higher Frequency tones loop/finish faster, so the Duration needs to be longer.
0205   00FA             .ORG $0100
0206   0100 09 FE       FRQTBL:         db $09, $FE
0207   0102 10 FD                       db $10, $FD
0208   0104 11 EF                       db $11, $EF
0209   0106 12 E1                       db $12, $E1
0210   0108 13 D4                       db $13, $D4
0211   010A 14 C9                       db $14, $C9
0212   010C 15 BE                       db $15, $BE
0213   010E 16 B2                       db $16, $B2
0214   0110 17 A9                       db $17, $A9
0215   0112 19 9F                       db $19, $9F
0216   0114 1A 96                       db $1A, $96
0217   0116 1C 8E                       db $1C, $8E
0218   0118 1E 86                       db $1E, $86
0219   011A 20 7F                       db $20, $7F
0220   011C 22 77                       db $22, $77
0221   011E 24 71                       db $24, $71
0222   0120 26 6A                       db $26, $6A
0223   0122 28 64                       db $28, $64
0224   0124 2A 5F                       db $2A, $5F
0225   0126 2D 59                       db $2D, $59
0226   0128 2F 54                       db $2F, $54
0227   012A 32 50                       db $32, $50
0228   012C 35 4B                       db $35, $4B
0229   012E 38 47                       db $38, $47
0230   0130 3C 43                       db $3C, $43
0231   0132 3F 3F                       db $3F, $3F
0232   0134 43 3C                       db $43, $3C
0233   0136 47 38                       db $47, $38
0234   0138 4B 35                       db $4B, $35
0235   013A 50 32                       db $50, $32
0236   013C 54 2F                       db $54, $2F
0237   013E 59 2D                       db $59, $2D
0238   0140 5F 2A                       db $5F, $2A
0239   0142 64 28                       db $64, $28
0240   0144 6A 26                       db $6A, $26
0241   0146 71 24                       db $71, $24
0242   0148 77 22                       db $77, $22
0243   014A 7F 20                       db $7F, $20
0244   014C 86 1E                       db $86, $1E
0245   014E 8E 1C                       db $8E, $1C
0246   0150 96 1A                       db $96, $1A
0247   0152 9F 19                       db $9F, $19
0248   0154 A9 17                       db $A9, $17
0249   0156 B2 16                       db $B2, $16
0250   0158 BE 15                       db $BE, $15
0251   015A C9 14                       db $C9, $14
0252   015C D4 13                       db $D4, $13
0253   015E E1 12                       db $E1, $12
0254   0160 EF 11                       db $EF, $11
0255   0162 FD 10                       db $FD, $10
0256   0164 FE 09                       db $FE, $09
0257   0166             
0258   0166                             .ORG $0170              ; a is the tone number
0259   0170 C5          PLAYTONE:       push bc                 ; save bc,de,hl,af
0260   0171 D5                          push de
0261   0172 E5                          push hl
0262   0173 F5                          push af
0263   0174 A7                          and a                   ; Set Zero flag if A is Zero
0264   0175 20 03                       jr nz,PTnotZero         ; If the tone in A is 0,
0265   0177 5F                          ld e,a                  ;   then Load E with A (which is Zero)
0266   0178 18 02                       jr PTZero               ;   and Jump Rel to PTZero
0267   017A 1E 80       PTnotZero:      ld e,$80                ; Else Load E with 80h; high bit is speaker
0268   017C 21 00 01    PTZero:         ld hl,FRQTBL            ; Load HL with the base address of the division table for frequencies
0269   017F 87                          add a,a                 ; Frequencies are 2 bytes long, so multiply A (tone offset) by 2
0270   0180 85                          add a,l                 ; Add the now duplicated offset into L
0271   0181 6F                          ld l,a                  ; Load the result of the addition in L, back into A
0272   0182 4E                          ld c,(hl)               ; Load the duration of the Tone into C
0273   0183 23                          inc hl                  ; Point HL to the second byte of the freq divisor
0274   0184 46          LENGTHLOOP:     ld b,(hl)               ; Load the Frequency of the Tone into B
0275   0185 7B                          ld a,e                  ; Load A with E (which is either $00 or $80)
0276   0186 D3 01                       out ($01),a             ; Output A to Port 01
0277   0188 10 FE       HIGHWAVE:       djnz HIGHWAVE           ; repeat while (--b > 0) - Length of high part of "waveform"
0278   018A 46                          ld b,(hl)               ; restore b
0279   018B AF                          xor a                   ; a = 0
0280   018C D3 01                       out ($01),a             ; speaker bit = 0
0281   018E 10 FE       LOWWAVE:        djnz LOWWAVE            ; repeat while (--b > 0) - Length of low part of "waveform"
0282   0190 0D                          dec c                   ; c--
0283   0191 20 F1                       jr nz,LENGTHLOOP        ; if (c != 0) goto lengthloop
0284   0193 F1                          pop af                  ; restore bc,de,hl,af
0285   0194 E1                          pop hl
0286   0195 D1                          pop de
0287   0196 C1                          pop bc
0288   0197 C9                          ret                     ; return
0289   0198             
0290   0198                             .ORG $01A0              ; MUSIC routine.
0291   01A0 F5          PLAYTUNE:       push af
0292   01A1 E5                          push hl
0293   01A2 2A D6 08    STARTTUNE:      ld hl,(TUNEADDR)
0294   01A5 7E          LOADNOTE:       ld a,(hl)
0295   01A6 FE FF                       cp $FF                  ; If the tune loads a value of FF, signifies end of Tune
0296   01A8 20 03                       jr nz,PLAYNOTE
0297   01AA E1                          pop hl
0298   01AB F1                          pop af
0299   01AC C9                          ret
0300   01AD FE FE       PLAYNOTE        cp $FE                  ; If the tune loads a value of FE, signifies to Repeat the Tune
0301   01AF 28 F1                       jr z,STARTTUNE
0302   01B1 23                          inc hl
0303   01B2 CD 70 01                    call PLAYTONE           ; Subroutine that plays the note loaded in A
0304   01B5 18 EE                       jr LOADNOTE
0305   01B7             
0306   01B7                             .ORG $01C0              ; The ADDRESS Key routine:
0307   01C0 21 DF 08    KEYADDRESS:     ld hl,MODE              ; If currently in ADDRESS mode
0308   01C3 CB 46                       bit 0,(hl)              ; then change the MODE bits to
0309   01C5 20 07                       jr nz,FLIPON            ; turn it into DATA mode.
0310   01C7 CB C6                       set 0,(hl)              ; If not in ADDRESS mode, then make it so.
0311   01C9 CB 8E                       res 1,(hl)
0312   01CB C3 72 03                    jp POP_HLAF
0313   01CE CB 86       FLIPON:         res 0,(hl)
0314   01D0 CB CE                       set 1,(hl)
0315   01D2 C3 72 03                    jp POP_HLAF             ; Restore HL and AF then return to calling function.
0316   01D5             
0317   01D5                             .ORG $01d8              ; MULTIPASS DISPLAY
0318   01D8 C5                          push bc                 ; Save BC
0319   01D9 06 80                       ld b,$80                ; B is used as the digit selector
0320   01DB CD A0 02    MPDISPLAY:      call DISPLAY            ; DISPLAY routine sets the segments according to the data and then lights them up
0321   01DE 10 FB                       djnz MPDISPLAY          ; Repeat for each digit
0322   01E0 C1                          pop bc                  ; Restore BC
0323   01E1 C9                          ret
0324   01E2 FF                          db $FF
0325   01E3 FF                          db $FF
0326   01E4             
0327   01E4 ED 4B D2 08 KEYSHPLUS:      ld bc,(SHIFTINS)
0328   01E8 CD 90 04                    call SETEDITADDR
0329   01EB CD 42 02                    call GETADDRDATA
0330   01EE C3 72 03                    jp POP_HLAF
0331   01F1 FF                          db $FF
0332   01F2             
0333   01F2 ED 4B D4 08 KEYSHMINUS:     ld bc,(SHIFTDEL)        ; Delete and shift down routine
0334   01F6 CD 90 04                    call SETEDITADDR
0335   01F9 CD 42 02                    call GETADDRDATA
0336   01FC C3 72 03                    jp POP_HLAF
0337   01FF             
0338   01FF             .ORG $0200                              ; Main monitor program entry point.
0339   0200             STARTMON:
0340   0200 21 00 00                    ld HL,$0000             ; Clear the data in VECTOR6
0341   0203 22 CC 08                    Ld (VECTOR6), HL
0342   0206 3E FF                       ld a,$ff
0343   0208 32 E0 08                    ld (KEYDATA),a          ; Set the KEY buffer = $FF
0344   020B 31 C0 08                    ld sp,STACKSTART        ; Set stack pointer to $08C0
0345   020E AF                          xor a                   ; Clear A
0346   020F D3 01                       out ($01),a             ; Blank the Diplays
0347   0211 D3 02                       out ($02),a             ; (Do this to ALL ports to clear the 8x8 as well)
0348   0213 D3 03                       out ($03),a
0349   0215 D3 04                       out ($04),a
0350   0217 D3 05                       out ($05),a
0351   0219 D3 06                       out ($06),a
0352   021B D3 07                       out ($07),a
0353   021D 21 B0 00                    ld hl,INITADDR          ; Load HL with $0900, the initial start address
0354   0220 11 D8 08                    ld de,ADDRESS1          ; Load DE with the display address pointer
0355   0223 01 05 00                    ld bc,$0005             ; Load BC with 5
0356   0226 ED B0                       ldir                    ; Copies the 5 (why 5??) bytes from HL to DEMOTEXT
0357   0228 CD 42 02    BEEPMON:        call GETADDRDATA
0358   022B 3E 08                       ld a,$08
0359   022D CD 70 01                    call PLAYTONE
0360   0230 3E 0F                       ld a,$0f
0361   0232 CD 70 01                    call PLAYTONE
0362   0235 3E 01                       ld a,$01
0363   0237 32 DF 08                    ld (MODE),a
0364   023A CD A0 02    MAINLOOP:       call DISPLAY
0365   023D CD 5C 03                    call GETKEY
0366   0240 18 F8                       jr MAINLOOP
0367   0242             
0368   0242 F5          GETADDRDATA:    push af                 ; Loads the data at the current Monitor pointed address
0369   0243 E5                          push hl                 ; and places it into the Display Buffer bytes for digits 1 and 0
0370   0244 C5                          push bc                 ; save registers
0371   0245 CD 5B 02                    call GETEDITADDR        ; Loads current address into BC (but is lost, later)
0372   0248 E6 F0                       and $f0                 ; Mask off the upper nibble. Rotate the byte to move the upper nibble to the lower nibble
0373   024A 0F                          rrca
0374   024B 0F                          rrca
0375   024C 0F                          rrca
0376   024D 0F                          rrca
0377   024E 32 DC 08                    ld (DATA1),a            ; Load the left (high) nibble into DATA1 location
0378   0251 0A                          ld a,(bc)
0379   0252 E6 0F                       and $0f
0380   0254 32 DD 08                    ld (DATA2),a            ; Load the right (low) nibble into DATA2 location
0381   0257 C1                          pop bc
0382   0258 E1                          pop hl
0383   0259 F1                          pop af
0384   025A C9                          ret
0385   025B             
0386   025B             ;GetEditorAddress
0387   025B             ;The address used by editor and shown on the 7 segment display is stored in one
0388   025B             ;location only, to prevent a situation where displayed address and real address
0389   025B             ;could differ. In a trade off in processing time, it was more efficient to store
0390   025B             ;the address in the optimal form for the display routine. As such it needs
0391   025B             ;converting to and from this format when used by the monitor program.
0392   025B             ;The chosen location is the display buffer, where the address is broken into
0393   025B             ;nibbles and spread across four bytes, 08D8, 08D9, 08DA, 08db, MSN to LSN.
0394   025B             ;GetEditorAddress is used to retrieve this address.
0395   025B             ;The data held here is only valid while the monitor program is running. As soon as
0396   025B             ;something else is written to the display it is lost. Resetting the computer
0397   025B             ;restores it to the default 0900h.
0398   025B             ;
0399   025B             ;GetEditorAddress, when called, loads BC with the address currently held In the
0400   025B             ;display buffer. It also loads A with the data held at the location addressed by BC.
0401   025B             ;
0402   025B             ; E.G. If the LED display shows 0900 CD, calling GETEDITADDR will load BC with 0900 (B is
0403   025B             ;the MSB) and loads A with CD. This routine is not transparent. HL is destroyed. BC
0404   025B             ;and A hold the results. If this routine is called during a user program that is not
0405   025B             ;an extension to the monitor, the result will have no meaning.
0406   025B 21 D8 08    GETEDITADDR:    ld hl,ADDRESS1
0407   025E 7E                          ld a,(hl)
0408   025F 07                          rlca
0409   0260 07                          rlca
0410   0261 07                          rlca
0411   0262 07                          rlca
0412   0263 23                          inc hl
0413   0264 86                          add a,(hl)
0414   0265 47                          ld b,a
0415   0266 23                          inc hl
0416   0267 7E                          ld a,(hl)
0417   0268 07                          rlca
0418   0269 07                          rlca
0419   026A 07                          rlca
0420   026B 07                          rlca
0421   026C 23                          inc hl
0422   026D 86                          add a,(hl)
0423   026E 4F                          ld c,a
0424   026F 0A                          ld a,(bc)
0425   0270 C9                          ret
0426   0271             
0427   0271                             .ORG $02A0
0428   02A0 F5          DISPLAY:        push af                 ;save registers
0429   02A1 E5                          push hl
0430   02A2 D5                          push de
0431   02A3 C5                          push bc                 ;DE is loaded with the start of the 4 bytes holding
0432   02A4 11 D8 08                    ld de,ADDRESS1          ;the current Monitor Address being displayed
0433   02A7 AF                          xor a                   ;a = 0
0434   02A8 D3 01                       out ($01),a             ;clear digit port
0435   02AA CD 50 03                    call HEX2SEG            ;Convert the nibble located at DE to into segments and store in A
0436   02AD CB 4E                       bit 1,(hl)              ;Check Bit 1 of the MODE register (Address mode)
0437   02AF 28 02                       jr z,NODOT1             ;If we are in Address mode...
0438   02B1 CB E7                       set 4,a                 ;set segment 4 of digit (decimal point indicating Address mode)
0439   02B3 D3 02       NODOT1:         out ($02),a             ;output a to segment port
0440   02B5 3E 20                       ld a,$20                ;digit 020 (the left-most digit)
0441   02B7 D3 01                       out ($01),a             ;output a to digit port
0442   02B9 06 20                       ld b,$20                ;loop count of 20
0443   02BB 10 FE       DELAY1:         djnz DELAY1             ;Allow a count of 20 to show display
0444   02BD AF                          xor a                   ;Repeat for 2nd address Digit
0445   02BE D3 01                       out ($01),a             ;clear digit port
0446   02C0 CD 50 03                    call HEX2SEG            ;
0447   02C3 CB 4E                       bit 1,(hl)              ;
0448   02C5 28 02                       jr z,NODOT2             ;
0449   02C7 CB E7                       set 4,a                 ;
0450   02C9 D3 02       NODOT2:         out ($02),a             ;output a to segment port
0451   02CB 3E 10                       ld a,$10                ;digit 010
0452   02CD D3 01                       out ($01),a             ;output a to digit port
0453   02CF 06 20                       ld b,$20                ;
0454   02D1 10 FE       DELAY2:         djnz DELAY2             ;delay by 20
0455   02D3 AF                          xor a                   ;
0456   02D4 D3 01                       out ($01),a             ;clear digit port
0457   02D6 CD 50 03                    call HEX2SEG            ;
0458   02D9 CB 4E                       bit 1,(hl)              ;
0459   02DB 28 02                       jr z,NODOT3             ;
0460   02DD CB E7                       set 4,a                 ;
0461   02DF D3 02       NODOT3:         out ($02),a             ;output a to segment port
0462   02E1 3E 08                       ld a,$08                ;digit 080
0463   02E3 D3 01                       out ($01),a             ;output a to digit port
0464   02E5 06 20                       ld b,$20                ;
0465   02E7 10 FE       DELAY3:         djnz DELAY3               ;delay by 20
0466   02E9 AF                          xor a                   ;
0467   02EA D3 01                       out ($01),a             ;clear digit port
0468   02EC CD 50 03                    call HEX2SEG            ;
0469   02EF CB 4E                       bit 1,(hl)              ;
0470   02F1 28 02                       jr z,NODOT4             ;
0471   02F3 CB E7                       set 4,a
0472   02F5 D3 02       NODOT4:         out ($02),a             ;output a to segment port
0473   02F7 3E 04                       ld a,$04                ;digit 040
0474   02F9 D3 01                       out ($01),a             ;output a to digit port
0475   02FB 06 20                       ld b,$20
0476   02FD 10 FE       DELAY4:         djnz DELAY4             ;delay by 20
0477   02FF AF                          xor a                   ;
0478   0300 D3 01                       out ($01),a             ;clear digit port
0479   0302 00                          nop                     ;
0480   0303 C3 18 03                    jp DISPLAY2
0481   0306             
0482   0306 CD 5B 02    KEYGO:          call GETEDITADDR        ; GO button has been pressed
0483   0309 C5                          push bc                 ; Use the stack to
0484   030A E1                          pop hl                  ; LD HL with BC
0485   030B 31 C0 08                    ld sp,STACKSTART
0486   030E E9                          jp (hl)                 ; Start executing code from the address loaded in HL
0487   030F             
0488   030F                             .ORG $0318              ;
0489   0318 CD 50 03    DISPLAY2:       call HEX2SEG            ; DISPLAY2 displays the two Data Digits (5th & 6th)
0490   031B CB 46                       bit 0,(hl)              ; Check if we are in DATA mode
0491   031D 28 02                       jr z,$0321              ; If we are then...
0492   031F CB E7                       set 4,a                 ; Set the dot to indicate DATA mode.
0493   0321 D3 02       NODOT5:         out ($02),a
0494   0323 3E 02                       ld a,$02                ;digit 020
0495   0325 D3 01                       out ($01),a             ;output a to digit port
0496   0327 06 20                       ld b,$20
0497   0329 10 FE       DELAY5:         djnz DELAY5             ;delay by 20
0498   032B AF                          xor a
0499   032C D3 01                       out ($01),a             ;clear digit port
0500   032E CD 50 03                    call HEX2SEG
0501   0331 CB 46                       bit 0,(hl)
0502   0333 28 02                       jr z,NODOT6
0503   0335 CB E7                       set 4,a
0504   0337 D3 02       NODOT6:         out ($02),a
0505   0339 3E 01                       ld a,$01                ;digit 040
0506   033B D3 01                       out ($01),a             ;output a to digit port
0507   033D 06 20                       ld b,$20
0508   033F 10 FE       DELAY6:         djnz DELAY6             ;delay by 20
0509   0341 AF                          xor a
0510   0342 D3 01                       out ($01),a             ;clear digit port
0511   0344 C1                          pop bc                  ;restore registers
0512   0345 D1                          pop de
0513   0346 E1                          pop hl
0514   0347 F1                          pop af
0515   0348 C9                          ret                     ;return
0516   0349             
0517   0349             ;Hex2SevenSeg converts the Hex value (0 to 29) into the
0518   0349             ;corresponding seven-segment data. It is part of the display routine.
0519   0349             ;HL is destroyed, DE is incremented, A is converted from the value to its
0520   0349             ;7 segment form.
0521   0349                             .ORG $0350              ;Hex2SevenSeg
0522   0350 21 80 00    HEX2SEG:        ld hl,SEVSEGDATA        ;HL pointing to start of 7seg data
0523   0353 1A                          ld a,(de)               ;Load A with the contents of (de) - but what is at (de)?
0524   0354 85                          add a,l                 ;Add L to the contents of A
0525   0355 6F                          ld l,a                  ;Then load A back into L
0526   0356 7E                          ld a,(hl)               ;a = (hl + a)
0527   0357 13                          inc de                  ;de++
0528   0358 21 DF 08                    ld hl,MODE              ;hl = mode
0529   035B C9                          ret                     ;return
0530   035C             
0531   035C F5          GETKEY:         push af                 ; KEYDATA is the keyboard buffer address
0532   035D E5                          push hl                 ; which is filled with $FF after the key data is read
0533   035E 21 E0 08                    ld hl,KEYDATA           ;hl = KEYDATA
0534   0361 3E FF                       ld a,$ff
0535   0363 BE                          cp (hl)                 ; if the buffer still holds $FF,
0536   0364 28 0C                       jr z,POP_HLAF           ; no key pressed and return
0537   0366 7E                          ld a,(hl)               ;  a = (KEYDATA)
0538   0367 E6 1F                       and $1f                 ;  Mask off the high 3 bits
0539   0369 CB 6E                       bit 5,(hl)              ;  test if the Shift bit 5 is on
0540   036B 20 02                       jr nz,NOSHIFT           ;  if (shift) is on, then
0541   036D C6 14                       add a,$14               ;    add $14 to the contents of A
0542   036F C3 98 03    NOSHIFT:        jp KEYBLIP
0543   0372             
0544   0372 E1          POP_HLAF:       pop hl                  ;restore hl, af
0545   0373 F1                          pop af
0546   0374 C9                          ret
0547   0375             
0548   0375                                                     ; Routine used to effectively delete a byte of data
0549   0375 CD 5B 02    SHIFTMEMDN:     call GETEDITADDR        ; by shifting all data above current address down one byte.
0550   0378                                                     ; BC has the current memory address.
0551   0378 C5                          push bc                 ; Using the stack...
0552   0379 DD E1                       pop ix                  ; Load IX with the contents of BC
0553   037B DD 23       LOOPDOWN:       inc ix                  ; Increment IX (so it points to Current+1)
0554   037D DD E5                       push ix                 ; Use stack to copy IX...
0555   037F E1                          pop hl                  ; and load it into HL
0556   0380 7C                          ld a,h
0557   0381 FE 40                       cp $40                  ; Check if we are at max memory address of $4000
0558   0383 28 08                       jr z,MAXMEM             ; if so, then jump... else...
0559   0385 DD 7E 00                    ld a,(ix+0)             ; Load A with data at (IX) which is Current+1
0560   0388 DD 77 FF                    ld (ix-1),a             ; Save the data to the current memory location
0561   038B 18 EE                       jr LOOPDOWN             ; Loop back and do it again
0562   038D             
0563   038D 3E 00       MAXMEM:         ld a,$00                ; Clear A
0564   038F 32 FF 3F                    ld ($3fff),a            ; Load $00 into the top memory location.
0565   0392 CD 42 02                    call GETADDRDATA
0566   0395 C3 72 03                    jp POP_HLAF
0567   0398             
0568   0398 C6 01       KEYBLIP:        add a,$01               ; Not sure why $01 is added... Makes it a higher tone?
0569   039A CD 70 01                    call PLAYTONE           ; Key blip that goes higher for each key - Which is annoying, TBH
0570   039D C3 1C 04                    jp WHICHKEY
0571   03A0             
0572   03A0 CD 5B 02    SHIFTMEMUP:     call GETEDITADDR
0573   03A3 0B                          dec bc
0574   03A4 DD 21 FE 3F                 ld ix,$3ffe             ; Select the 2nd to last byte and then
0575   03A8 DD 7E 00    LOOPUP:         ld a,(ix+0)             ; Copy it into the highest byte
0576   03AB DD 77 01                    ld (ix+1),a             ; then repeat until the BC = HL
0577   03AE DD 2B                       dec ix
0578   03B0 DD E5                       push ix
0579   03B2 E1                          pop hl
0580   03B3 79                          ld a,c
0581   03B4 BD                          cp l
0582   03B5 20 F1                       jr nz,LOOPUP            ; Repeat until C = L
0583   03B7 78                          ld a,b
0584   03B8 BC                          cp h
0585   03B9 20 ED                       jr nz,LOOPUP            ; Repeat until B = H
0586   03BB DD 36 01 00                 ld (ix+1),$00
0587   03BF CD 42 02                    call GETADDRDATA
0588   03C2 C3 72 03                    jp POP_HLAF
0589   03C5             
0590   03C5                             .ORG $03d8              ; RUNNING WRITING
0591   03D8 E5          RUNWRITING:     push hl                 ; Save registers
0592   03D9 F5                          push af
0593   03DA DD E5                       push ix
0594   03DC C5                          push bc
0595   03DD AF                          xor a                   ; Clear A
0596   03DE 32 DF 08                    ld (MODE),a             ; Set MODE to 0
0597   03E1 06 06                       ld b,$06                ; Load B with 6 (number of display digits)
0598   03E3 21 D8 08                    ld hl,ADDRESS1          ; load HL with the current user memory address
0599   03E6 3E 29                       ld a,$29                ; not sure why you'd load A with 29H ??
0600   03E8 77          LOAD29H:        ld (hl),a               ; Put A (with 29H) into (HL)
0601   03E9 23                          inc hl                  ;
0602   03EA 10 FC                       djnz LOAD29H            ; Loop 6 times
0603   03EC 2A DC 08    REPEATMSG:      ld hl,(DATA1)           ;
0604   03EF 7E          LOADCHAR:       ld a,(hl)               ;
0605   03F0 FE FF                       cp $ff                  ; Is the character just loaded an $FF (signifies end of string)
0606   03F2 20 06                       jr nz,STARTMSG          ;    If not, then JUMP to...
0607   03F4 C1                          pop BC                  ; otherwise restore the registers
0608   03F5 DD E1                       pop ix
0609   03F7 F1                          pop af
0610   03F8 E1                          pop hl
0611   03F9 C9                          ret                     ; and end the routine
0612   03FA FE FE       STARTMSG:       cp $fe                  ; org $3FA
0613   03FC 28 EE                       jr z,REPEATMSG          ; if the character is $FE, this marks it as the Repeat message
0614   03FE DD 21 D8 08                 ld ix,ADDRESS1
0615   0402 06 05                       ld b,$05                ; Loop count $05
0616   0404 DD 7E 01    DISROTL:        ld a,(ix+1)             ; Rotate right 5 digits to the left
0617   0407 DD 77 00                    ld (ix+0),a
0618   040A DD 23                       inc ix
0619   040C 10 F6                       djnz DISROTL            ; Loop back till 5 digits done
0620   040E 7E                          ld a,(hl)
0621   040F 32 DD 08                    ld (DATA2),a
0622   0412 23                          inc hl
0623   0413 06 40                       ld b,$40                ; Loop count $40
0624   0415 CD A0 02    DISLOOP:        call DISPLAY            ; org $0415
0625   0418 10 FB                       djnz DISLOOP            ; Multiplex the Display $40 times
0626   041A 18 D3                       jr LOADCHAR
0627   041C             
0628   041C D6 01       WHICHKEY:       sub $01                 ; Subtract the $01 that was added for the Key Blip
0629   041E 36 FF                       ld (hl),$ff             ; Reset the Keyboard buffer back to $FF
0630   0420 CB 67                       bit 4,a                 ; Test if bit 4 (the control keys) is set
0631   0422 C2 C0 04                    jp nz,CTRLKEY           ;   If so, jumpt to the routine handling non-data keys
0632   0425 CB 6F                       bit 5,a                 ; Test if the SHIFT key is pressed
0633   0427 C2 C0 04                    jp nz,CTRLKEY           ;   If so, jumpt to the routine handling non-data keys
0634   042A 21 DF 08                    ld hl,MODE
0635   042D CB 46                       bit 0,(hl)              ; Check MODE-0
0636   042F CA 55 04                    jp z,MODE0OFF           ;   Jump if MODE-0 is off
0637   0432 57                          ld d,a
0638   0433 CD 5B 02                    call GETEDITADDR
0639   0436 21 DF 08                    ld hl,MODE
0640   0439 CB 5E                       bit 3,(hl)              ; Is MODE-3 on?
0641   043B 20 03                       jr nz,MODE3ON           ; If so, then jump
0642   043D AF                          xor a                   ; Set A to 0
0643   043E CB DE                       set 3,(hl)              ; Set MODE-3 to ON
0644   0440 07          MODE3ON:        rlca                    ; Rotate lower nibble to top
0645   0441 07                          rlca
0646   0442 07                          rlca
0647   0443 07                          rlca
0648   0444 E6 F0                       and $f0                 ; Mask off the lower data
0649   0446 82                          add a,d
0650   0447 02                          ld (bc),a
0651   0448 CD 42 02                    call GETADDRDATA
0652   044B C3 72 03                    jp POP_HLAF
0653   044E             
0654   044E                             .ORG $0455              ;
0655   0455 57          MODE0OFF:       ld d,a
0656   0456 21 DF 08                    ld hl,MODE
0657   0459 CB 9E                       res 3,(hl)
0658   045B CB 66                       bit 4,(hl)
0659   045D 20 08                       jr nz,MODEJUMP
0660   045F 01 00 00                    ld bc,$0000
0661   0462 CD 90 04                    call SETEDITADDR
0662   0465 CB E6                       set 4,(hl)
0663   0467 CD 5B 02    MODEJUMP:       call GETEDITADDR
0664   046A 78                          ld a,b
0665   046B 07                          rlca
0666   046C 07                          rlca
0667   046D 07                          rlca
0668   046E 07                          rlca
0669   046F E6 F0                       and $f0
0670   0471 5F                          ld e,a
0671   0472 79                          ld a,c
0672   0473 07                          rlca
0673   0474 07                          rlca
0674   0475 07                          rlca
0675   0476 07                          rlca
0676   0477 E6 0F                       and $0f
0677   0479 83                          add a,e
0678   047A 47                          ld b,a
0679   047B 79                          ld a,c
0680   047C 07                          rlca
0681   047D 07                          rlca
0682   047E 07                          rlca
0683   047F 07                          rlca
0684   0480 E6 F0                       and $f0
0685   0482 82                          add a,d
0686   0483 4F                          ld c,a
0687   0484 CD 90 04                    call SETEDITADDR
0688   0487 CD 42 02                    call GETADDRDATA
0689   048A C3 72 03                    jp POP_HLAF
0690   048D             
0691   048D             ;SetEditorAddress is the opposite of the GetEditorAddress routine.
0692   048D             ;It loads the display buffer (ADDRESS1 - ADDRESS4) with the
0693   048D             ;value held in BC. No registers affected.
0694   048D             
0695   048D                             .ORG $0490               ;SetEditorAddress
0696   0490 F5          SETEDITADDR:    push af                 ;save af, hl
0697   0491 E5                          push hl
0698   0492 21 D8 08                    ld hl,ADDRESS1          ;hl points to ADDRESS buffer
0699   0495 78                          ld a,b                  ;a = b
0700   0496 E6 F0                       and $f0                 ;mask out lower nibble
0701   0498 07                          rlca                    ;rotate upper nibble into lower nibble
0702   0499 07                          rlca
0703   049A 07                          rlca
0704   049B 07                          rlca
0705   049C 77                          ld (hl),a               ;(hl) = a
0706   049D 23                          inc hl                  ;hl++
0707   049E 78                          ld a,b                  ;a = b
0708   049F E6 0F                       and $0f                 ;mask lower nibble
0709   04A1 77                          ld (hl),a               ;(hl) = a
0710   04A2 23                          inc hl                  ;hl++
0711   04A3 79                          ld a,c                  ;a = c
0712   04A4 E6 F0                       and $f0                 ;mask upper nibble
0713   04A6 07                          rlca                    ;rotate upper nibble into lower nibble
0714   04A7 07                          rlca
0715   04A8 07                          rlca
0716   04A9 07                          rlca
0717   04AA 77                          ld (hl),a               ;(hl) = a
0718   04AB 23                          inc hl                  ;hl++
0719   04AC 79                          ld a,c                  ;a = c
0720   04AD E6 0F                       and $0f                 ;mask lower nibble
0721   04AF 77                          ld (hl),a               ;Save A into location (HL)
0722   04B0 E1                          pop hl                  ;restore hl, af
0723   04B1 F1                          pop af
0724   04B2 C9                          ret                     ;return
0725   04B3             
0726   04B3                             .ORG $04C0               ;
0727   04C0 21 DF 08    CTRLKEY:        ld hl,MODE                  ; A big CASE routine to determine which control key is pressed
0728   04C3 CB 9E                       res 3,(hl)                  ; This modifies the MODE setting.
0729   04C5 CB A6                       res 4,(hl)
0730   04C7 FE 10                       cp $10
0731   04C9 CA E0 00                    jp z,KEYPLUS                ; The PLUS key was pressed
0732   04CC FE 11                       cp $11
0733   04CE CA E6 00                    jp z,KEYMINUS               ; The MINUS key was pressed
0734   04D1 FE 12                       cp $12
0735   04D3 CA 06 03                    jp z,KEYGO                  ; The GO button was pressed
0736   04D6 FE 13                       cp $13
0737   04D8 CA C0 01                    jp z,KEYADDRESS             ; The ADdress button was pressed
0738   04DB FE 14                       cp $14
0739   04DD CA 42 05                    jp z,SHIFTJUMP              ; The SHIFT and ADdress key is pressed
0740   04E0 FE 15                       cp $15
0741   04E2 CA FF FF                    jp z,$ffff
0742   04E5 FE 16                       cp $16
0743   04E7 CA FF FF                    jp z,$ffff
0744   04EA FE 17                       cp $17
0745   04EC CA F2 01                    jp z,KEYSHMINUS
0746   04EF FE 18                       cp $18
0747   04F1 CA 70 05                    jp z,USERPOSTBURN            ; USER burnt routine in EPROM after release.
0748   04F4 FE 19                       cp $19
0749   04F6 CA FF FF                    jp z,$ffff
0750   04F9 FE 1A                       cp $1a
0751   04FB CA FF FF                    jp z,$ffff
0752   04FE FE 1B                       cp $1b
0753   0500 CA FF FF                    jp z,$ffff
0754   0503 FE 1C                       cp $1c
0755   0505 CA 60 06                    jp z,$0660
0756   0508 FE 1D                       cp $1d
0757   050A CA FF FF                    jp z,$ffff
0758   050D FE 1E                       cp $1e
0759   050F CA FF FF                    jp z,$ffff
0760   0512 FE 1F                       cp $1f
0761   0514 CA FF FF                    jp z,$ffff
0762   0517 FE 20                       cp $20
0763   0519 CA FF FF                    jp z,$ffff
0764   051C FE 21                       cp $21
0765   051E CA FF FF                    jp z,$ffff
0766   0521 FE 22                       cp $22
0767   0523 CA FF FF                    jp z,$ffff
0768   0526 FE 23                       cp $23
0769   0528 CA FF FF                    jp z,$ffff
0770   052B FE 24                       cp $24
0771   052D CA A0 03                    jp z,SHIFTMEMUP             ; The SHIFT and PLUS keys
0772   0530 FE 25                       cp $25
0773   0532 CA 75 03                    jp z,SHIFTMEMDN             ; The SHIFT and MINUS keys
0774   0535 FE 26                       cp $26
0775   0537 CA FF FF                    jp z,$ffff
0776   053A FE 27                       cp $27
0777   053C CA E4 01                    jp z,KEYSHPLUS
0778   053F C3 72 03                    jp POP_HLAF
0779   0542             
0780   0542 CD 5B 02    SHIFTJUMP:      call GETEDITADDR
0781   0545 60                          ld h,b
0782   0546 69                          ld l,c
0783   0547 3A E1 08                    ld a,(X3)
0784   054A 23          LOOPJUMP:       inc hl
0785   054B BE                          cp (hl)
0786   054C 20 FC                       jr nz,LOOPJUMP
0787   054E 44                          ld b,h
0788   054F 4D                          ld c,l
0789   0550 CD 90 04                    call SETEDITADDR
0790   0553 C3 28 02                    jp BEEPMON
0791   0556             
0792   0556                             .ORG $0570
0793   0570 00          USERPOSTBURN:   db $00
0794   0571             
0795   0571             .ORG $0700                              ;Keyboard Remap Data
0796   0700 00 01 02 03                 DB $00, $01, $02, $03   ;This key map is the original TEC-1 layout.
0797   0704 04 05 06 07                 DB $04, $05, $06, $07   ;Keep the same data structure, but change the
0798   0708 08 09 0A 0B                 DB $08, $09, $0A, $0B   ;values to REMAP the data read from the 74C923
0799   070C 0C 0D 0E 0F                 DB $0C, $0D, $0E, $0F   ;to any keyboard layout you wish.
0800   0710 10                          DB $10                  ;Plus Key
0801   0711 11                          DB $11                  ;Minus Key
0802   0712 12                          DB $12                  ;Go Key
0803   0713 13                          DB $13                  ;Address Key
0804   0714             
0805   0714             ;.ORG $0700                              ;An Alternative Keyboard Map with Monitor Keys on the right.
0806   0714             ;                DB $0F, $02, $05, $08   ;
0807   0714             ;                DB $0E, $03, $06, $09   ;
0808   0714             ;                DB $0D, $0C, $0B, $0A   ;
0809   0714             ;                DB $10, $11, $12, $13   ;
0810   0714             ;                DB $00                  ;Plus Key
0811   0714             ;                DB $01                  ;Minus Key
0812   0714             ;                DB $04                  ;Go Key
0813   0714             ;                DB $07                  ;Address Key
0814   0714             
0815   0714             .ORG $0720                              ;Remap keys to Table specified @ $0700
0816   0720 E6 1F       KEYREMAP:       AND $1f                 ;mask lower 5 bits
0817   0722 26 07                       LD H, $07               ;Use the table at $0700 to load A with a key value
0818   0724 6F                          LD L, A
0819   0725 7E                          LD A, (HL)
0820   0726 CB 68                       BIT 5,B                 ;Test if Shift Key was pressed
0821   0728 28 02                       JR Z, SAVEKEY           ;Shift is pressed - Skip next line
0822   072A CB EF                       SET 5,A                 ;Set Bit 5 High to avoid Shift processing
0823   072C 32 E0 08    SAVEKEY:        ld (KEYDATA),a          ;save A into ram
0824   072F C9                          ret
0825   0730             
0826   0730             .ORG $07F0                              ;VERSION DATA
0827   07F0 4D 4F 4E 32 VERSION:        .DB     "MON2.A1 "
0827   07F4 2E 41 31 20 
0828   07F8 32 30 32 32                 .DB     "2022.MJ "
0828   07FC 2E 4D 4A 20 
Number of errors = 0
