0000                             ; 
0000                             ;JMON - JIM'S MONITOR
0000                             ;BY JIM ROBERTSON
0000                             ; 
0000                             ; 
0000                             ;FILENAME : JMON_SRC_01.ASM
0000                             ;VERSION : 1
0000                             ; 
0000                             ;This version has been beautified by Brian Chiha, December 2021
0000                             ;and was cleaned up by Mark Jelic, June 2021
0000                             ;[Lovingly] RESTORED TO SOURCE FROM PDF LISTING(S) FEBRUARY 2021
0000                             ;[by Craig Jones. What a champion effort! - MJ]
0000                             ; 
0000                             ;THE PHOTOCOPIED PDF LISTING WAS CONVERTED TO A TEXT FILE VIA OCR
0000                             ;THE MISSING PAGE 9 WAS TAKEN FROM ANOTHER VERSION OF THE LISTING
0000                             ;PAGE NUMBERS REFER TO THE PHOTOCOPIED LISTING PDF FILE
0000                             ; 
0000                             ; 
0000                             ;GLOSSARY
0000                             ; 
0000                             ;CURRENT EDITING LOCATION (082E)
0000                             ;THIS IS THE ADDRESS THAT IS USUALLY DISPLAYED IN THE ADDRESS SECTION ON THE TEC LED
0000                             ;DISPLAY. IT IS THE ADDRESS THAT IS SUBJECT TO MODIFICATION BY JMON.
0000                             ; 
0000                             ;MONITOR CONTROL BYTE (MCB) (082B)
0000                             ;THIS BYTE CONTAINS THE INFORMATION OF THE CURRENT WORKING STATE OF JMON. THE INFORMATION
0000                             ;HELD IN THIS BYTE IS:
0000                             ;1 - THE CURRENT MODE OF JMON.
0000                             ;E.G. DATA, ADDRESS OR FUNCTION (NOT SHIFT AS SHIFT IS TESTED AND HANDLED DURING THE DATA
0000                             ;KEY HANDLER ROUTINE). BITS 4 AND 5 ENCODE THE CURRENT MODE IN THE FOLLOWING WAY. BOTH
0000                             ;BITS ARE LOW FOR THE DATA MODE, BIT 4 IS HIGH FOR THE ADDRESS MODE, BITS 4 AND 5 ARE HIGH
0000                             ;FOR THE FUNCTION MODE. BIT 4 IS CALLED THE ADDRESS/FUNCTION BIT As THE SOFTWARE ONLY
0000                             ;NEEDS TO TEST THIS BIT TO FIND IF EITHER THE ADDRESS OR FUNCTION MODE IS ACTIVE. BIT 5
0000                             ;IS THE FUNCTION MODE ENABLED BIT.
0000                             ;2 - THE NUMBER OF THE CURRENT FUNCTION I.E. 1,2 OR 3.
0000                             ;THIS IS ENCODED IN BITS 2 AND 3. IF NO FUNCTION OR FUNCTION-1 IS ENABLED THEN BOTH BITS
0000                             ;ARE LOW. IF FUNCTION-2 IS SELECTED THEN BIT 2 IS HIGH AND BIT 3 IS LOW. IF FUNCTION-3 IS
0000                             ;SELECTED THEN BIT 3 IS HIGH AND BIT 2 IS LOW.
0000                             ;3 - THE NUMBER OF NIBBLES ENTERED
0000                             ;THIS IS ENCODED IN BITS 0 AND 1. IF NO NIBBLES HAVE BEEN ENTERED IN THE CURRENT EDITING
0000                             ;LOCATION THEN BOTH BIT ARE LOW. IF ONE NIBBLE HAS BEEN ENTERED THEN BIT 0 IS HIGH AND
0000                             ;BIT 1 IS LOW IS TWO NIBBLES HAVE BEEN ENTERED THEN BIT 0 IS LOW AND BIT 1 IS HIGH. JMON
0000                             ;USES THESE BITS WHEN DECIDING ON THE AUTO-INCREMENT FEATURE. BITS 6 AND 7 ARE NOT USED.
0000                             ; 
0000                             ;DISPLAY BUFFER ADDRESS - (082C/D)
0000                             ;THE CONTENTS OF 082C/D POINTS TO THE LOCATION IN MEMORY OF THE 6 BYTE DISPLAY BUFFER
0000                             ;(0800 FOR JMON AND 0806 FOR THE STEPPER). THE DISPLAY BUFFER ADDRESS POINTS TO THE LOWEST
0000                             ;ADDRESS OF THE DISPLAY BUFFER WHICH CONTAINS THE LOW ORDER DATA DISPLAY BYTE.
0000                             ; 
0000                             ;KEY PLANT
0000                             ;THE KEY PLANT IS A FAKE KEY STROKE THAT MAY BE GENERATED BY THE "DURING SCAN/REY LOOP"
0000                             ;USER PATCH. THE PLANT ALLOWS JMON'S MONITOR FUNCTIONS TO BE SOFTWARE CONTROLLED E.G. YOU
0000                             ;MAY WISH TO VIEW THE CONTENTS ,OF MEMORY BYTE BY BYTE. WITH THE KEY PLANT YOU CAN SET JMON
0000                             ;UP TO AUTOMATICALLY INCREMENT THE CURRENT EDIT LOCATION EVERY FEW SECONDS.
0000                             ;THE PLANT IS IDENTIFIED BY THE USER PATCH STORING THE REQUIRED KEY VALUE IN, AND SETTING
0000                             ;BIT 7 OF THE INPUT KEY BUFFER (0820).
0000                             ; 
0000                             ;AUTO KEY STATUS BYTE (082A)
0000                             ;THIS BYTE HOLDS THE INFORMATION REQUIRED FOR THE AUTO KEY REPEAT SECTION. THE INFORMATION
0000                             ;HELD IN THIS BYTE IS EITHER ONE OF THE FOLLOWING:
0000                             ;A "NEXT KEY DETECTION WILL BE A FIRST DETECTION" SO JMON WILL PROCESS THE KEY IMMEDIATELY
0000                             ;(BIT 7 HIGH) . A TIMER (BITS 0-6) THAT COUNTS, A DELAY FOR THE AUTO. REPEAT TIMING.
0000                             ; 
0000                             ;KEY PRESS FLAG (0825)
0000                             ;THIS FLAG IS USED TO REMEMBER IF THE ONE KEY PRESS HAS ALREADY BEEN DETECTED AND PROCESSED.
0000                             ;THIS PREVENTS THE SAME KEY BEING PROCESSED EACH TIME THE SOFTWARE FINDS THAT IT IS PUSHED.
0000                             ;THIS IS THE WAY IT WORKS:
0000                             ;THE KEY PRESS FLAG 1S ZEROED BY THE JMON DEFAULT VARIABLES AND THIS FLAGS A "NO KEY
0000                             ;PRESSED" STATE. WHEN A KEY IS DETECTED THEN THIS FLAG IS TESTED AND IF ZERO THEN THE KEY
0000                             ;IS ACCEPTED AS A FIRST KEY PRESS. IN THIS CASE THE KEY PRESS FLAG IS THEN SET TO FF TO
0000                             ;REMEMBER THAT THE KEY PRESS HAS BEEN DETECTED. IF A KEY IS DETECTED AND THIS FLAG BYTE
0000                             ;IS NOT ZERO, THEN THE KEY IS IGNORED. WHEN THE SOFTWARE FINDS THAT NO KEY IS BEING PRESSED,
0000                             ;THEN THIS FLAG IS CLEARED TO ALLOW THE NEXT KEY PRESS DETECTED TO BE PROCESSED.
0000                             ;THIS FLAG IS USED BY THE RST 08, RST 10 RST 18 AND RST 20 KEYBOARD ROUTINES AS DESCRIBED
0000                             ;IN ISSUE 15 TALKING ELECTRONICS AND ALSO THE STEPPER SOFTWARE.
0000                             ;THE AUTO KEY REPEAT ROUTINE DOES NOT USE THIS FLAG BYTE, DO NOT CONFUSE THIS FLAG WITH
0000                             ;THE AUTO KEY STATUS BYTE WHICH IS USED BY THE AUTO KEY REPEAT SECTION.
0000                             ; 
0000                             ;TAPE FILE INFORMATION BLOCK
0000                             ;THIS IS A 12 BYTE BLOCK THAT CONTAINS THE FOLLOWING INFORMATION:
0000                             ;THE START ADDRESS OF THE BLOCK, THE NUMBER OF BYTES IN THE BLOCK, THE FILE NUMBER AND AN
0000                             ;OPTIONAL GO ADDRESS OR FFFF IF OPTIONAL GO IS DISABLED. THE OTHER 4 BYTES ARE NOT USED
0000                             ;AT THIS STAGE.
0000                             ;THIS BLOCK IS OUTPUTTED AND INPUTTED TO AND FROM THE TAPE ON EACH TAPE OPERATION.
0000                             ; 
0000                             ;"NEXT PC" BUFFER
0000                             ;THIS IS A TEMPORARY PLACE TO SAVE THE RETURN ADDRESS WHICH IS THEN USED AS THE ACTUAL PC
0000                             ;VALUE FOR THE NEXT INSTRUCTION STEPPED.
0000                             ; 
0000                             ;FORCED HARD RESET
0000                             ;THIS IS ACHIEVED BY HOLDING DOWN A KEY WHEN RELEASING THE RESET. THE HARD RESET CAUSES
0000                             ;JMON TO RE-BOOT ITS VARIABLES AND ALSO MASK OFF ALL THE USER PATCHES (EXCEPT THE RESET
0000                             ;PATCH). THE MAIN PURPOSE OF A FORCED HARD RESET IS TO RECOVER THE TEC IF A USER PATCH
0000                             ;ENTERS A CONTINUOUS LOOP.
0000                             ; 
0000                             ; 
0000                REG_TBL:   EQU   0794H - 2   ;BASE OF REGISTER NAME TABLE
0000                DISP_BUFF:   EQU   0800H   ;Current displayed Address Buffer
0000                DISP_DBUFF:   EQU   0804H   ;Current displayed Data Buffer
0000                DISP_D2BUF:   EQU   0805H   ;Character #2 of the Data Display Buffer
0000                DISP_STEP:   EQU   0806H   ;Stepper's 6 Byte Display Buffer
0000                             ; 
0000                             ;USER VARIABLE START LOCATION
0000                V_KEY:    EQU   0820H   ;KEY BUFFER
0000                V_LCD:    EQU   0821H   ;LCD ON/OFF FLAG
0000                V_BEEP:   EQU   0822H   ;SOUND ON/OFF
0000                V_ALT_ADDF:   EQU   0823H   ;GO AT ALTERNATE GO ADDRESS IF AA
0000                V_STEP_TMR:   EQU   0824H   ;STEPPER KEY CONTROL/TIMER
0000                V_KEY_PRES:   EQU   0825H   ;KEY PRESS FLAG
0000                V_SPARE1:   EQU   0826H   ;UNUSED
0000                V_AUTO:   EQU   0827H   ;AUTO INCREMENT ON/OFF
0000                V_ALT_ADDR:   EQU   0828H   ;ALT GO ADDR/SOFT RESET EDIT LOCATION
0000                V_KAUTO:   EQU   082AH   ;AUTO KEY STATUS BYTE
0000                V_MCB:    EQU   082BH   ;MONITOR CONTROL BYTE (MCB)
0000                V_DISPLAY:   EQU   082CH   ;DISPLAY BUFFER ADDRESS (using 7seg Display codes)
0000                V_CEL:    EQU   082EH   ;CURRENT EDITING LOCATION (CEL)
0000                             ; 
0000                             ;The following are the JUMP addresses that a CALLED by JMON,
0000                             ;after they are copied from the ROM (starting @ 071Fh) to the RAM @ 0830h, on a Hard Reset.
0000                             ;They point back to routines in the ROM, so not sure why this was done.
0000                HL_2_DIS:   EQU   0830H   ;CONVERT HL TO DISPLAY CODE @ 01D5h
0000                A_2_DISP:   EQU   0833H   ;CONVERT A TO DISPLAY CODE @ 01DAh
0000                LED_SCAN:   EQU   0836H   ;LED SCAN ROUTINE @ 01BAh
0000                SET_DOTS:   EQU   0839H   ;SET LED DOTS @ 01EEh
0000                BEEPBEEP:   EQU   083CH   ;RESET TONES @ 0224h (TWO BEEPS)
0000                BEEP:     EQU   083FH   ;TONE @ 0227h
0000                SCAN_IO:   EQU   0842H   ;SCAN/KEY/LCD/PATCH LOOP @ 0181h
0000                DO_DISP:   EQU   0845h   ;SOFT JMON ENTRY L0845 @ 00B2h
0000                LCD_DISP:   EQU   0848H   ;LCD ROUTINE @ 023Ch
0000                             ; 
0000                             ;Various other Monitor Locations to help with its functionality
0000                PATCH_BEF:   EQU   084BH   ;PRE-SCAN USER PATCH
0000                PATCH_DUR:   EQU   084EH   ;USER "DURING LOOP" PATCH
0000                PATCH_AFT:   EQU   0851H   ;USER "AFTER KEY" PATCH
0000                STEP_NEXT:   EQU   0858H   ;ADDRESS OF INSTRUCTION JUST STEPPED
0000                STEP_CREG:   EQU   085AH   ;CURRENT REG No. BUFFER
0000                RE_ENTRY:   EQU   0860H   ;RE-ENTRY ADDRESS BUFFER
0000                STEP_PREV:   EQU   0868H   ;"NEXT PC" BUFFER
0000                STEP_REGS:   EQU   086Ah   ;SHIFT 7 ROUTINE START (REG DISPLAY)
0000                HL_SAVE:   EQU   086EH   ;HL SAVE ON RESET
0000                STEP_HL:   EQU   0870H   ;STEPPER INITIAL HL
0000                STEP_SP:   EQU   087EH   ;Stack Pointer Save Buffer
0000                PERI_MENU:   EQU   0880H   ;PERIMITER MENU SETUP
0000                PERI_D_TBL:   EQU   0882H   ;PERIMITER DATA SEGMENT TABLE
0000                PERI_W_ADD:   EQU   0884H   ;PERIMITER WINDOW ENTRY START LOCATION
0000                PERI_W_CUR:   EQU   0886H   ;CURRENT PERIMETER WINDOW
0000                PERI_W_MAX:   EQU   0887H   ;TOTAL PERIMETER WINDOWS
0000                PERI_J_ADR:   EQU   0888H   ;PERIMITER GO JUMP ADDRESS
0000                TAPE_ACTN:   EQU   088AH   ;TAPE OPERATION (0=LOAD, 2=TEST, 3=CHECKSUM)
0000                PERI_W_AC1:   EQU   088CH   ;PERIMITER ACTIVE WINDOW + 1
0000                MENU_NO:   EQU   088FH   ;MENU ENTRY NUMBER
0000                MENU_J_TBL:   EQU   0891H   ;MENU JUMP TABLE
0000                MENU_A_TBL:   EQU   0893H   ;MENU ADDRESS SEGMENT TABLE
0000                MENU_D_TBL:   EQU   0895H   ;MENU DATA SEGMENT TABLE
0000                MENU_KEYRN:   EQU   0897H   ;MENU DATA KEY RETURN HANDLER (USE C9 IF N/A)
0000                TAPE_FILE:   EQU   0898H   ;TAPE FILE NAME (NUMBER)
0000                TAPE_START:   EQU   089AH   ;TAPE START ADDRESS (DEFAULT TO FFFF)
0000                TAPE_END:   EQU   089CH   ;TAPE END ADDRESS
0000                TAPE_AUTOG:   EQU   089EH   ;TAPE AUTO GO ADDRESS (DEFUALT TO FFFF)
0000                TAPE_O_FIL:   EQU   08A4H   ;TAPE OUTPUT FILE NAME (NUMBER)
0000                TAPE_O_STA:   EQU   08A6H   ;TAPE OUTPUT START ADDRESS
0000                TAPE_O_LEN:   EQU   08A8H   ;TAPE OUTPUT LENGTH
0000                TAPE_O_GO:   EQU   08AAH   ;TAPE OUTPUT AUTO GO ADDRESS
0000                PATCH_REQ:   EQU   08B0H   ;RESET PATCH REQUIRED IF 0xAA IS HERE
0000                PATCH_STA:   EQU   08B1H   ;RESET PATCH START ADDRESS. 0x08B1-0x08B2
0000                PATCH_VAR:   EQU   08B3H   ;RESET PATCH VARIABLE.  0X08B4 Size of Patch
0000                PATCH_CHK:   EQU   08B5h   ;RESET PATCH CHECKSUM
0000                PATCH_ADR:   EQU   08B6H   ;RESET PATCH ADDRESS. 0x08B6-0x08B7
0000                USER_TBL:   EQU   08C0H - 2   ;User Table -2
0000                RST_FLAG:   EQU   08FFH   ;Reset Flag
0000                JMON_UTIL:   EQU   3800H   ;JMON UTILITIES ADDRESS START LOCATION 
0000                JMON_UJMP:   EQU   381Eh   ;START OF THE JUMP TABLE IN THE JMON UTILITIES
0000                             ; 
0000                             ;IO Port ASSIGNMENTS
0000                KEYBOARD:   EQU   0x00   ;KEYBOARD ENCODER
0000                DSCAN:    EQU   0x01   ;DISPLAY CATHODE DRIVER LATCH
0000                DSEGMENT:   EQU   0x02   ;DISPLAY SEGMENT DRIVER LATCH
0000                             ; 
0000                             ;DAT BOARD
0000                P_DAT:    EQU   0x03   ;DAT BOARD LATCH
0000                P_LCDDATA:   EQU   0x84   ;LCD DATA REGISTER
0000                P_LCDINST:   EQU   0x04   ;LCD INSTRUCTION REGISTER
0000                             ; 
0000                             ;KEYBOARD REFERENCES
0000                K_PLUS:   EQU   0x10   ;+ KEY
0000                K_MINUS:   EQU   0x11   ;- KEY
0000                K_GO:     EQU   0x12   ;GO KEY
0000                K_ADDR:   EQU   0x13   ;ADDRESS KEY
0000                             ; 
0000                             ; 
0000                             ;AT THE START OF JMON, HL IS SAVED IN ITS SINGLE STEPPER BUFFER ADD THE SOFT RESET DISPLAY
0000                             ;VALUE IS PLACED IN THE CURRENT EDIT LOCATION BUFFER. THE ROUTINE THEN IS CONTINUED AT $0068.
0000                          .ORG   $0000   
0000   22 6E 08               LD   (HL_SAVE),HL   ;SAVE HL PART OF REGISTER SAVE
0003   2A 28 08               LD   HL,(V_ALT_ADDR)   ;GET SOFT RESET INITIAL EDIT
0006   18 63                  JR   MON_START   ;LOCATION AND CONTINUE AT 006B
0008                             ; 
0008                             ;RST 08 AND RST 10 (CF AND D7)
0008                             ;THESE TWO COMBINE TOGETHER TO SIMULATE A HALT INSTRUCTION. THIS IS DONE BY LOOPING UNTIL
0008                             ;THE CURRENT (IF ANY) KEY PRESS IS RELEASED (RST 08), AND THEN LOOPING UNTIL A NEW KEY
0008                             ;PRESS IS DETECTED (RST 10).
0008                             ; 
0008   E7           RST08:    RST   20H   ;TEST FOR KEY PRESS
0009   28 FD                  JR   Z,RST08   ;LOOP IF KEY PRESSED
000B   00                     NOP      ;ELSE
000C   00                     NOP      ;MOVE
000D   00                     NOP      ;TO
000E   00                     NOP      ;NEXT
000F   00                     NOP      ;RST
0010   E7           RST10:    RST   20H   ;TEST FOR KEY AGAIN
0011   20 FD                  JR   NZ,RST10   ;LOOP IF KEY NOT PRESSED
0013   E6 1F                  AND   0x1F   ;MASK OFF JUNK BITS
0015   ED 47                  LD   I,A   ;STORE IN INTERRUPT REGISTER
0017   C9                     RET      ;DONE
0018                             ; 
0018                             ;RST 18 (DF) AND RST 20 (E7)
0018                             ;RST 18 CALLS THE LED SCAN ROUTINE ONCE THEN MOVES ON INTO RST 20 THAT THEN CALLS A KEYBOARD
0018                             ;READ ROUTINE.
0018                             ;THE KEYBOARD MUST BE READ CONTINUOUSLY OVER A PERIOD OF TIME, AS THE DATA AVAILABLE SIGNAL
0018                             ;(BIT 6, PORT 3) (USUALLY) PULSES, WHEN A KEY IS PRESSED, IN TIME WITH THE KEY ENCODER
0018                             ;CHIP'S SCANNING. IF THE KEY BOARD IS READ ONLY ONCE EVERY SECOND, THEN THE SOFTWARE MAY
0018                             ;AND PROBABLY) WILL TARE SEVERAL SECONDS TO DETECT THE KEY.
0018                             ;THE NUMBER OF READ CYCLES FOR THE KEYBOARD IS LOADED INTO B.
0018                             ; 
0018   E5           RST18:    PUSH   HL   ;SAVE HL
0019   D5                     PUSH   DE   ;AND DE
001A   CD 36 08               CALL   LED_SCAN   ;CALL SCAN ROUTINE
001D   D1                     POP   DE   ;RECOVER DE
001E   E1                     POP   HL   ;AND HL
001F   00                     NOP      ;NEXT RST
0020   C5           RST20:    PUSH   BC   ;SAVE BC
0021   06 20                  LD   B,0x20   ;B = NUMBER OF KEYBOARD SCAN LOOPS
0023   CD AD 06               CALL   KEY_READ   ;CALL KEY READER/VALIDATER
0026   C1                     POP   BC   ;RECOVER BC
0027   C9                     RET      ;DONE
0028                             ; 
0028                             ;RST 28 (EF)
0028                             ;START STEPPING FROM THE INSTRUCTION FOLLOWING THE RST 28
0028   E3           RST28:    EX   (SP),HL   ;GET RETURN ADDRESS FROM THE STACK
0029   22 58 08               LD   (STEP_NEXT),HL   ;PUT IN "NEXT PC" BUFFER
002C   E3                     EX   (SP),HL   ;FIX UP STACK
002D   FB                     EI      ;ENABLE INTERRUPTS
002E   C9                     RET      ;STEPPING WILL OCCUR AFTER RETURN
002F   FF                     DB   0xFF   ;SPARE
0030                             ; 
0030                             ;RST 30 (F7)
0030                             ;TEST THE BUSY STATE OF THE LCD AND LOOP WHILE BUSY
0030   DB 04        RST30:    IN   A,(P_LCDINST)   ;READ STATUS BIT FROM LCD
0032   07                     RLCA      ;PUT IN CARRY
0033   38 FB                  JR   C,RST30   ;LOOP IF LCD BUSY
0035   C9                     RET      ;DONE
0036   FF FF                  DB   0xFF,0xFF   ;SPARE
0038                             ; 
0038                             ;RST 38 (FF)
0038                             ;INTERRUPT HANDLER FOR STEPPER AND BREAK-POINTS
0038   C3 12 03     RST38:    JP   STEPPER   ;JUMP TO STEPPER ROUTINE
003B   FF FF FF FF FF FF      DB   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF   ;SPARE
0041                             ; 
0041                             ;JUMP TABLE FOR EXTERNAL SOFTWARE TO USE JMON ROUTINES
0041   C3 DD 03     L0041:    JP   MENU_RTN   ;MENU ROUTINE
0044   C3 79 04     L0044:    JP   PERI_RTN   ;PERIMETER HANDLER ENTRY
0047   C3 ED 03     L0047:    JP   MENU_SFT   ;SOFT MENU ENTRY
004A   C3 9F 06     L004A:    JP   ERR_ENTRY   ;ERR-IN ENTRY
004D   C3 B3 05     L004D:    JP   PF_ENTRY   ;PASS/FAIL/MENU
0050   C3 A3 04     L0050:    JP   PERI_SFT   ;SOFT PERIMETER HANDLER ENTRY
0053   FF FF FF FF FF FF FF   DB   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF   ;SPARE
005A   FF FF FF FF            DB   0xFF,0xFF,0xFF,0xFF   ;SPARE
005E                             ; 
005E                             ;SHIFT-2 ROUTINE
005E                             ;THIS STORES THE CURRENT EDIT LOCATION IN THE "NEXT PC" BUFFER. THE INTERRUPTS ARE THEN
005E                             ;ENABLED AND THE PROGRAM JUMPS TO THE USER ROUTINE TO BE STEPPED. STEPPING OCCURS AT THE
005E                             ;CURRENT EDIT LOCATION (CEL).
005E   2A 2E 08     FN_STEPPER:   LD   HL,(V_CEL)   ;PUT CURRENT EDIT LOCATION IN
0061   22 58 08               LD   (STEP_NEXT),HL   ;"NEXT PC" BUFFER
0064   FB                     EI      ;ENABLE INTERRUPTS
0065   E9                     JP   (HL)   ;START STEPPING
0066                             ; 
0066                             ;NMI HANDLER (IMMEDIATE RETURN)
0066   ED 45                  RETN      ;IGNORE NMI
0068   FF                     RST   38H   ;RESERVED
0069   FF                     RST   38H   ;FOR A "Post Burn"
006A   FF                     RST   38H   ;JUMP LOCATION
006B                             ; 
006B                             ;CONTINUATION OF MONITOR
006B   ED 56        MON_START:   IM   1   ;SET INTERRUPT MODE 1 FOR STEPPER
006D   22 2E 08               LD   (V_CEL),HL   ;STORE SOFT RESET INITIAL CEL
0070   21 76 00               LD   HL,MON_START2   ;LOAD HL WITH RE-ENTRY ADDRESS
0073   C3 18 03               JP   SAVE_REGS   ;JUMP TO SAVE REGISTERS
0076                             ; 
0076                             ; 
0076                             ;RE-ENTRY POINT AFTER SAVING REGISTERS
0076   31 20 08     MON_START2:   LD   SP,V_KEY   ;SET STACK (to the Keyboard Buffer??)
0079   CD F7 02               CALL   RST_PATCH   ;CALL RESET PATCH HANDLER
007C   E7                     RST   20H   ;LOOK FOR FORCED HARD RESET
007D   28 07                  JR   Z,HARD_RST   ;JUMP KEY PRESSED TO HARD RESET
007F   3A FF 08               LD   A,(RST_FLAG)   ;CHECK HARD/RESET FLAG
0082   FE AA                  CP   0xAA   ;FOR AA
0084   28 1C                  JR   Z,SOFT_RST   ;JUMP TO SOFT RESET IF AA
0086                             ; 
0086                             ;HARD RESET
0086                             ;MONITOR DEFAULT VARIABLES ARE RE-BOOTED AND USER PATCHES MASKED OFF.
0086                             ; 
0086   21 0F 07     HARD_RST:   LD   HL,DEF_VARS   ;LOAD HL WITH START OF JMON DEFAULT
0089   11 20 08               LD   DE,V_KEY   ;VARIABLES ROM TABLE
008C   01 2B 00               LD   BC,0x002B   ;DE IS THE RAM DE(stination)
008F   ED B0                  LDIR      ;AND BC THE COUNT: MOVE TABLE
0091   06 03                  LD   B,0x03   ;MASK OF THE THREE USER PATCHES
0093   3E C9                  LD   A,0xC9   ;BY PUTTING A RETURN AT THE FIRST
0095   12           L0095:    LD   (DE),A   ;LOCATION OF EACH
0096   13                     INC   DE   ; 
0097   13                     INC   DE   ; 
0098   13                     INC   DE   ; 
0099   10 FA                  DJNZ   L0095   ; 
009B   CD D5 06               CALL   LCD_RESET   ;INITIALIZE/TEST FOR THE LCD
009E   AF                     XOR   A   ;CLEAR HARD/SOFT
009F   32 FF 08               LD   (RST_FLAG),A   ;RESET FLAG
00A2                             ; 
00A2                             ;THIS SECTION IS THE SOFT RESET SECTION. IT IS ALSO PART OF THE HARD RESET SECTION.
00A2   21 00 38     SOFT_RST:   LD   HL,JMON_UTIL   ;TEST FOR JMON UTILITIES ROM
00A5   7E                     LD   A,(HL)   
00A6   FE C3                  CP   0xC3   ;AND CALL ITS RESET ROUTINE
00A8   CC 00 38               CALL   Z,JMON_UTIL   ;IF REQUIRED
00AB   CD 3C 08               CALL   BEEPBEEP   ;CALL RESET TONE ROUTINE (BEEP BEEP)
00AE   AF           FN_S_RST:   XOR   A   ;CLEAR MONITOR CONTROL BYTE
00AF   32 2B 08               LD   (V_MCB),A   ;0 = DATA MODE, NO NIBBLES ENTERED
00B2                             ; 
00B2                             ;EACH TIME A KEYBOARD INPUT OR USER PATCH "PLANT", IS PROCESSED, THE PROGRAM JUMPS BACK
00B2                             ;TO HERE SO THE DISPLAYS MAY BE UP-DATED.
00B2                             ; 
00B2   2A 2E 08     J_DISPUPD:   LD   HL,(V_CEL)   ;GET CURRENT EDIT LOCATION (CEL)
00B5   ED 4B 2C 08            LD   BC,(V_DISPLAY)   ;AND DISPLAY BUFFER ADDRESS
00B9   CD 30 08               CALL   HL_2_DIS   ;AND CONVERT CEL TO DISPLAY CODE
00BC   7E                     LD   A,(HL)   ;AND THEN CONVERT CONTENTS OF
00BD   CD 33 08               CALL   A_2_DISP   ;CEL TO DISPLAY CODE
00C0   CD 39 08               CALL   SET_DOTS   ;CALL THE SET DOTS ROUTINE
00C3   CD 42 08               CALL   SCAN_IO   ;CALL SCAN/KEY/LCD/PATCH ROUTINE
00C6                             ; 
00C6                             ;THE SECTION BELOW IS EXECUTED WHEN EITHER A KEY OR KEY "PLANT" IS DETECTED IN THE
00C6                             ;SCAN/KEY/LCD/PATCH ROUTINE ROUTINE
00C6                KEY_MGMT:      
00C6   2A 2E 08               LD   HL,(V_CEL)   ;POINT HL TO CURRENT EDIT LOCATION
00C9   4F                     LD   C,A   ;PRESERVE INPUT KEY IN C
00CA   3A 2B 08               LD   A,(V_MCB)   ;GET MONITOR CONTROL BYTE (MCB)
00CD   CB 67                  BIT   4,A   ;TEST FOR ADDRESS OR FUNCTION MODE
00CF   47                     LD   B,A   ;STORE MCB IN B
00D0   79                     LD   A,C   ;GET INPUT KEY BACK IN A
00D1   20 2F                  JR   NZ,KEY_ADDR   ;JUMP IF ADDRESS OR FUNCTION MODE
00D3   FE 10        KEY_PLUS:   CP   K_PLUS   ;TEST FOR "+"
00D5   20 0C                  JR   NZ,KEY_MINUS   ;JUMP IF NOT TO TEST FOR "-"
00D7                             ; 
00D7                             ;"+" KEY HANDLER-(WHEN IN DATA MODE ONLY)
00D7                             ; 
00D7   23                     INC   HL   ;ADD 1 TO CURRENT EDIT LOCATION
00D8                             ; 
00D8                             ;COMMON CEL AND MCB UP-DATER
00D8                             ;SEVERAL SECTIONS JUMP HERE TO STORE AN UP-DATED CEL AND CLEAR THE NIBBLE COUNTER.
00D8                             ; 
00D8   22 2E 08     L00D8:    LD   (V_CEL),HL   ;STORE CEL
00DB   78                     LD   A,B   ;GET MCB
00DC                             ; 
00DC                             ;COMMON MCB UP-DATER
00DC                             ;SOME KEY HANDLER SECTION THAT DON'T REQUIRE.A NEW CEL (OR HAVE ALREADY STORED IT) JUMP HERE.
00DC                             ; 
00DC   E6 FC        L00DC:    AND   0xFC   ;CLEAR NIBBLE COUNTER
00DE   32 2B 08               LD   (V_MCB),A   ;STORE MCB
00E1   18 CF        L00E1:    JR   J_DISPUPD   ;JUMP BACK TO UPDATE DISPLAY
00E3   FE 11        KEY_MINUS:   CP   K_MINUS   ;TEST FOR "-"
00E5   20 03                  JR   NZ,KEY_GO   ;JUMP IF NOT TO TEST FOR "GO"
00E7                             ; 
00E7                             ;"-" KEY HANDLER (WHEN IN DATA MODE ONLY)
00E7   2B                     DEC   HL   ;DECREASE CEL ADDRESS BY ONE
00E8   18 EE                  JR   L00D8   ;JUMP TO COMMON CEL AND MCB UP-DATER
00EA   FE 12        KEY_GO:   CP   K_GO   ;TEST FOR GO
00EC   20 14                  JR   NZ,KEY_ADDR   ;JUMP IF NOT TO TEST FOR "AD"
00EE                             ; 
00EE                             ;"GO" HANDLER (WHEN IN DATA MODEONLY)
00EE   3A 23 08               LD   A,(V_ALT_ADDF)   ;TEST FOR ALTERNATE GO ADDRESS
00F1   FE AA                  CP   0xAA   ;IF (0823)=AA
00F3   28 05                  JR   Z,L00FA   ;JUMP IF SET FOR ALTERNATE GO ADDR
00F5   2A 2E 08               LD   HL,(V_CEL)   ;ELSE GET CURRENT EDIT LOCATION
00F8   18 03                  JR   L00FD   ;SKIP ALTERNATE JUMP ADDRESS FETCH
00FA   2A 28 08     L00FA:    LD   HL,(V_ALT_ADDR)   ;GET ALTERNATE GO ADDRESS
00FD   11 45 08     L00FD:    LD   DE,DO_DISP   ;PUT RETURN ADDRESS ON STACK
0100   D5                     PUSH   DE   
0101   E9                     JP   (HL)   ;START USER EXECUTION
0102                             ; 
0102                             ;TEST HERE FOR ADDRESS KEY. IF THE KEY PRESSED IS NOT THE ADDRESS KEY, THEN A JUMP IS
0102                             ;PERFORMED. OTHERWISE THE ADDRESS KEY IS PROCESSED.
0102                             ; 
0102   FE 13        KEY_ADDR:   CP   0x13   ;TEST FOR ADDRESS KEY
0104   20 0B                  JR   NZ,L0111   ;0= IF NOT TO DATA KEY HANDLER
0106   78                     LD   A,B   ;GET MONITOR CONTROL BYTE (MCB)
0107   CB 68                  BIT   5,B   ;TEST FOR FUNCTION MODE AND JUMP TO
0109   20 02                  JR   NZ,L010D   ;CLEAR FUNCTION MODE BITS IF SO
010B   EE 10                  XOR   0x10   ;ELSE TOGGLE ADDRESS MODE BIT
010D   E6 D3        L010D:    AND   0xD3   ;CLEAR ALL FUNCTION MODE BITS
010F   18 CB                  JR   L00DC   ;LOOP BACK TO COMMON MCB UP-DATER
0111                             ; 
0111                             ;A TEST FOR ADDRESS/FUNCTION MODE IS DONE. IF IN ADDRESS OR FUNCTION MODE A JUMP IS PERFORMED.
0111   78           L0111:    LD   A,B   ;GET MCB
0112   CB 67                  BIT   4,A   ;TEST FOR ADDRESS OR FUNCTION MODE
0114   20 25                  JR   NZ,KEY_CTRL   ;JUMP IF EITHER MODE
0116                             ; 
0116                             ;A TEST FOR SHIFT IS DONE AND A JUMP IS PERFORMED IF IN THE SHIFT MODE TO THE FUNCTION/SHIFT HANDLER.
0116   DB 00                  IN   A,(KEYBOARD)   ;TEST FOR THE SHIFT KEY
0118   CB 6F                  BIT   5,A   ;AND JUMP IF SHIFT IS PRESSED
011A   28 34                  JR   Z,KEY_FUNC   ;TO THE FUNCTION HANDLER
011C                             ; 
011C                             ;ANY TIME A DATA KEY IS PRESSED WHILE IN THE DATA MODE, IT IS PROCESSED STARTING HERE.
011C   78           KEY_DATA:   LD   A,B   ;GET MCB
011D   E6 03                  AND   0x03   ;MASK IT DOWN TO BYTE COUNTER
011F   FE 02                  CP   0x02   ;AND TEST FOR TWO NIBBLES ENTERED
0121   78                     LD   A,B   ;INPUT KEY VALUE BACK IN A
0122   20 0E                  JR   NZ,L0132   ;JUMP IF NOT READY FOR AUTO INC
0124   F5                     PUSH   AF   ;SAVE MCB
0125   3A 27 08               LD   A,(V_AUTO)   ;TEST AUTO INC MASK
0128   B7                     OR   A   ;IF NOT ZERO THEN JUMP AS USER
0129   20 04                  JR   NZ,L012F   ;HAS SWITCHED OFF AUTO INC MODE
012B   23                     INC   HL   ;ELSE INCREMENT CEL BEFORE ENTERING
012C   22 2E 08               LD   (V_CEL),HL   ;NEW NIBBLE AND STORE NEW CEL
012F   F1           L012F:    POP   AF   ;RECOVER MON CONTROL BYTE IN A
0130   E6 FC                  AND   0xFC   ;CLEAR BYTE COUNTER (BITS 0 AND 1)
0132   3C           L0132:    INC   A   ;ADD ONE TO NIBBLE COUNTER
0133   32 2B 08               LD   (V_MCB),A   ;STORE IT
0136   3A 20 08               LD   A,(V_KEY)   ;GET INPUT KEY FROM INPUT BUFFER
0139   18 11                  JR   L014C   ;JUMP TO ENTER IT
013B                             ; 
013B                             ;TEST HERE FOR A CONTROL KEY WHILE IN EITHER THE ADDRESS OR FUNCTION MODE AND JUMP TO
013B                             ;ENCODE THE FUNCTION NUMBER BITS (2 AND 3 OF MCB). IF NOT A CONTROL KEY, THEN TEST FOR
013B                             ;THE FUNCTION MODE AND JUMP TO FUNCTION JUMP CONTROL IF SO, ELSE SERVICE DATA KEY FOR
013B                             ;ADDRESS MODE.
013B                             ; 
013B   3A 20 08     KEY_CTRL:   LD   A,(V_KEY)   ;GET INPUT KEY FROM INPUT BUFFER
013E   CB 67                  BIT   4,A   ;TEST FOR CONTROL KEY (+,- OR GO)
0140   20 2F                  JR   NZ,ENC_FUNC   ;JUMP IF CONTROL TO FUNCTION ENCODER
0142   CB 68                  BIT   5,B   ;TEST FUNCTION MODE
0144   20 0A                  JR   NZ,KEY_FUNC   ;JUMP IF SO TO FUNCTION JUMP CONTROL
0146                             ; 
0146                             ;DATA KEY PRESS WHILE IN THE ADDRESS MODE
0146   21 2E 08               LD   HL,V_CEL   ;POINT HL TO CEL BUFFER
0149   ED 6F                  RLD      ;AND SHIFT IN THE NEW NIBBLE
014B   23                     INC   HL   ;AND MOVE THE OTHERS ACROSS
014C   ED 6F        L014C:    RLD      ;THIS RLD USED BY DATA MODE ALSO
014E   18 91        L014E:    JR   L00E1   ;JUMP (VIA A JUMP) TO UP-DATE DISPLAYS
0150                             ; 
0150                             ;FUNCTION AND SHIFT JUMP CONTROL
0150                             ;BITS 2 AND 3 OF THE MONITOR CONTROL BYTE (MCB) ARE THE FUNCTION IDENTIFIER BITS.
0150                             ;IF BOTH ARE ZERO THEN EITHER FUNCTION 1 IS SELECTED OR NO FUNCTION IS SELECTED. BECAUSE
0150                             ;THIS IS THE ALSO THE NO FUNCTION MODE ENABLED STATE, THE SHIFT KEY, WHICH DOES NOT AFFECT
0150                             ;THE MONITOR CONTROL BYTE, WILL ALSO WILL INVOKE FUNCTION 1. (THEREFORE THIS ROUTINE DOES
0150                             ;NOT NEED TO TEST FOR THE SHIFT KEY).
0150                             ;IF BIT 2 IS HIGH THEN FUNCTION 2 IS SELECTED AND IF BIT 3 IS HIGH THEN FUNCTION 3 IS
0150                             ;SELECTED.
0150                             ;DURING THIS ROUTINE, HL IS LOADED TO THE BASE OF THE REQUIRED JUMP TABLE MINUS TWO BYTES
0150                             ;(ONE ENTRY). THIS IS BECAUSE THE OFFSET PROVIDED FROM THE KEYBOARD HAS BEEN INCREMENTED
0150                             ;BY ONE. THIS SAVES TESTING FOR ZERO INPUT WHICH WOULD NOT ALLOW THE TABLE ACCESSING TO
0150                             ;WORK CORRECTLY. THE REQUIRED BASE IS FOUND BY EXAMINING THE STATE OF THE BITS 2 AND 3 OF
0150                             ;THE MONITOR CONTROL BYTE (MCB) AND LOADING HI, ACCORDINGLY.
0150                             ;AS EACH ENTRY IS TWO BYTES LONG, THE TABLE POINTER (THE VALUE INSIDE HL), IS INCREMENTED
0150                             ;TWICE FOR EACH DECREMENT OF THE INPUT VALUE (FROM THE KEYBOARD). WHEN THE REQUIRED TABLE
0150                             ;ENTRY IS FOUND, 17 IS PUT' INSIDE CEL (VIA_ DE) AND THE ROUTINE JUMPS TO PART OF THE "GO"
0150                             ;KEY ROUTINE TO CREATE A RETURN ADDRESS ON THE STACK AND EXECUTE THE SELECTED ROUTINE.
0150                             ; 
0150   78           KEY_FUNC:   LD   A,B   ;PUT MONITOR CONTROL BYTE IN A
0151   E6 0C                  AND   0x0C   ;MASK IT DOWN TO FUNCTION BITS
0153   21 DE 07               LD   HL,L07E0 - 2   ;JMON FUNCTION JUMP TABLE BASE -2
0156   28 0A                  JR   Z,L0162   ;JUMP IF FUNCTION 1 OR SHIFT
0158   21 BE 08               LD   HL,USER_TBL   ;LOAD HL WITH USER TABLE -2
015B                             ;*** Value is 08BE as User Table is at 08C0
015B   FE 04                  CP   0x04   ;TEST FOR FUNCTION 2
015D   28 03                  JR   Z,L0162   ;JUMP IF FUNCTION 2 (USER FUNCTION)
015F   21 1E 38               LD   HL,JMON_UJMP   ;OTHERWISE MUST BE FUNCTION 3
0162   3A 20 08     L0162:    LD   A,(V_KEY)   ;GET INPUT KEY FROM INPUT BUFFER
0165   3C                     INC   A   ;ADD ONE IN CASE IT WAS ZERO
0166   47                     LD   B,A   ;PUT IN B TO USE AS A LOOP COUNTER
0167   23           L0167:    INC   HL   ;LOOK THROUGH TABLE
0168   23                     INC   HL   ;FOR RIGHT JUMP VECTOR
0169   10 FC                  DJNZ   L0167   
016B   5E                     LD   E,(HL)   ;PUT IT IN HL
016C   23                     INC   HL   ;VIA DE
016D   56                     LD   D,(HL)   
016E   EB                     EX   DE,HL   ;JUMP TO CREATE RETURN ADDRESS AND
016F   18 8C                  JR   L00FD   ;EXECUTE SELECTED ROUTINE
0171                             ; 
0171                             ;FUNCTION NUMBER ENCODER
0171                             ;THIS SECTION ENCODES THE FUNCTION IDENTIFIER BITS (BITS 2 AND 3) IN THE MONITOR CONTROL
0171                             ;BYTE (BITS 2 AND 3) THEN SETS THE FUNCTION ENABLE BIT (BIT 5).
0171                             ;THE FUNCTION IDENTIFIER BITS ARE DERIVED FROM THE LEAST TWO SIGNIFICANT BITS OF THE INPUT
0171                             ;CONTROL KEY (+, AND GO). THESE ARE SHIFTED LEFT TWICE TO ALIGN THEM TO THE FUNCTION
0171                             ;SELECT BITS (BITS 2 AND 3) IN THE MCB. THE INPUT CONTROL KEY IS IN THE ACCUMULATOR ON
0171                             ;ENTRY AND THE MONITOR CONTROL BYTE (MCB) IN B.
0171                             ; 
0171   E6 03        ENC_FUNC:   AND   0x03   ;MASK DOWN CONTROL KEY
0173   07                     RLCA      ;SHIFT IT LEFT TWICE TO ALIGN BITS 0
0174   07                     RLCA      ;AND 1 TO FUNCTION IDENTITY BITS IN MCB
0175   F6 20                  OR   0x20   ;SET FUNCTION MODE ENABLED FLAG
0177   4F                     LD   C,A   ;SAVE IN C
0178   78                     LD   A,B   ;GET CURRENT MCB
0179   E6 D3                  AND   0xD3   ;CLEAR ANY PREVIOUS FUNCTION BITS
017B   B1                     OR   C   ;MERGE TOGETHER
017C   32 2B 08               LD   (V_MCB),A   ;STORE MCB
017F   18 CD                  JR   L014E   ;JUMP VIA JUMPS TO UP-DATE DISPLAYS
0181                             ; 
0181                             ;THIS IS THE SCAN/KEY/LCD/PATCH ROUTINE. THIS ROUTINE LOOPS SCANNING THE LED DISPLAY AND
0181                             ;SERVICING THE "DURING LOOP" USER PATCH UNTIL A KEY PRESS IS VALIDATED BY THE AUTO-KEY
0181                             ;REPEAT SECTION. THE INPUT KEY IS RETURNED IN THE ACCUMULATOR AND IN THE INPUT BUFFER AT
0181                             ;0820 WITH THE ZERO FLAG SET AND CARRY CLEARED.
0181                             ;THREE PATCHES ARE SUPPORTED IN THIS ROUTINE. THEY ARE A PATCH BEFORE LOOP, A PATCH DURING
0181                             ;THE LOOP AND A PATCH AFTER A VALID KEY PRESS.
0181                             ;THE "PLANT" IS A VALUE INSERTED INTO THE INPUT BUFFER (0820) BY THE DURING LOOP PATCH.
0181                             ;THE "PLANT" VALUE IS IDENTIFIED BY BIT 7 OF THE INPUT BUFFER BEING SET. BIT 7 IS RESET
0181                             ;BEFORE RETURNING TO SERVICE THE PLANT.
0181                             ;THIS ROUTINE USES A BYTE AT 082A, CALLED THE AUTO KEY STATUS BYTE AS A FLAG AND TIMER
0181                             ;TO GENERATE THE AUTO REPEAT DELAY.
0181                J_SCANKEY:      
0181   CD 48 08               CALL   LCD_DISP   ;CALL LCD ROUTINES
0184   CD 4B 08               CALL   PATCH_BEF   ;CALL PRE-SCAN USER PATCH
0187   CD 36 08     L0187:    CALL   LED_SCAN   ;CALL SCAN
018A   CD 4E 08               CALL   PATCH_DUR   ;CALL USER "DURING LOOP" PATCH
018D   21 20 08               LD   HL,V_KEY   ;TEST KEY INPUT BUFFER BIT 7 FOR A
0190   CB 7E                  BIT   7,(HL)   ;"PLANT" INSERTED BY USER DURING
0192   CB BE                  RES   7,(HL)   ;PATCH: RESET BIT 7 RETURN TO
0194   C0                     RET   NZ   ;SERVICE "PLANT" IF BIT 7 NOT ZERO
0195   E7                     RST   20H   ;TEST FOR KEY PRESS VIA RST 20
0196   21 2A 08               LD   HL,V_KAUTO   ;SET HL TO POINT TO AUTO KEY STATUS
0199   38 04                  JR   C,L019F   ;JUMP IF A KEY IS PRESSED
019B   36 80                  LD   (HL),0x80   ;ELSE SET AUTO KEY STATUS TO
019D   18 E8                  JR   L0187   ;NO KEY STATE AND CONTINUE LOOP
019F   CD CA 06     L019F:    CALL   KEY_GET   ;CALL UNIVERSAL KEY INPUTTER
01A2   CB 7E                  BIT   7,(HL)   ;TEST AUTO KEY STATUS FOR FIRST KEY
01A4   20 10                  JR   NZ,L01B6   ;JUMP IF SO TO SET LONG KEY DELAY
01A6   35                     DEC   (HL)   ;ELSE COUNT DOWN KEY DELAY
01A7   20 DE                  JR   NZ,L0187   ;LOOP IF NOT READY FOR KEY REPEAT
01A9   36 0C                  LD   (HL),0x0C   ;ELSE SET SHORT TIME DELAY BETWEEN
01AB   CD 51 08     L01AB:    CALL   PATCH_AFT   ;KEYS: CALL USER "AFTER KEY" PATCH
01AE   CD 3F 08               CALL   BEEP   ;CALL KEY TONE
01B1   AF                     XOR   A   ;SET ZERO FLAG AND CLEAR CARRY
01B2   3A 20 08               LD   A,(V_KEY)   ;PUT INPUT KEY IN A
01B5   C9                     RET      ;AND RETURN FOR KEY SERVICE
01B6   36 70        L01B6:    LD   (HL),0x70   ;SET KEY TIMER FOR LONG DELAY
01B8   18 F1                  JR   L01AB   ;JUMP TO SERVICE PATCH, TONE ETC.
01BA                             ; 
01BA                             ;THIS IS THE LED SCAN ROUTINE.
01BA                J_LEDSCAN:      
01BA   06 20                  LD   B,20H   ;B IS THE SCAN BIT
01BC   2A 2C 08               LD   HL,(V_DISPLAY)   ;GET ADDRESS OF DISPLAY BUFFER
01BF   7E           L01BF:    LD   A,(HL)   ;GET FIRST BYTE
01C0   D3 02                  OUT   (DSEGMENT),A   ;AND OUTPUT IT TO SEGMENTS
01C2   78                     LD   A,B   ;GET SCAN BIT
01C3   D3 01                  OUT   (DSCAN),A   ;OUTPUT IT TO COMMONS
01C5   06 40                  LD   B,40H   ;CREATE SHORT
01C7   10 FE        L01C7:    DJNZ   L01C7   ;DELAY IN B
01C9   23                     INC   HL   ;INCREASE HL TO NEXT DISPLAY BYTE
01CA   47                     LD   B,A   ;GET SCAN BIT BACK IN B
01CB   AF                     XOR   A   ;CLEAR THE LAST PORT OUTPUTTED TO
01CC   D3 01                  OUT   (DSCAN),A   ;TO PREVENT "GHOSTING"
01CE   CB 08                  RRC   B   ;SHIFT SCAN BIT ACROSS TO NEXT
01D0   30 ED                  JR   NC,L01BF   ;COMMON: WHEN SCAN BIT FALLS INTO
01D2   D3 02                  OUT   (DSEGMENT),A   ;CARRY SCAN IS TERMINATED: CLEAR
01D4   C9                     RET      ;PORT 2 AND RETURN
01D5                             ; 
01D5                             ;THIS ROUTINE CONVERTS HL TO DISPLAY CODE AND STORE THE DISPLAY CODE IN A BUFFER POINTED
01D5                             ;TO BY BC.
01D5                J_HL2CODE:      
01D5   7C                     LD   A,H   ;PUT H IN A
01D6   CD 33 08               CALL   A_2_DISP   ;CONVERT A TO DISPLAY CODE
01D9   7D                     LD   A,L   ;NOW DO FOR L
01DA                             ; 
01DA                             ;THIS SECTION CONVERTS THE BYTE IN A TO TWO DISPLAY BYTES.
01DA                J_A2CODE:      
01DA   F5                     PUSH   AF   ;SAVE A
01DB   07                     RLCA      ;SHIFT MSN TO LSN PLACE
01DC   07                     RLCA      ;FOR NIBBLE AT A TIME CONVERSION
01DD   07                     RLCA      
01DE   07                     RLCA      
01DF   CD E3 01               CALL   L01E3   ;CONVERT FIRST NIBBLE
01E2   F1                     POP   AF   ;RECOVER A TO CONVERT SECOND NIBBLE
01E3   E6 0F        L01E3:    AND   0x0F   ;MASK OF HIGH NIBBLE
01E5   11 D0 07               LD   DE,SEG_TBL   ;SET DE TO BASE OF CONVERSION
01E8   83                     ADD   A,E   ;TABLE: ADD A TO BASE
01E9   5F                     LD   E,A   ;UPDATE POINTER
01EA   1A                     LD   A,(DE)   ;GET DISPLAY CODE
01EB   02                     LD   (BC),A   ;STORE IN DISPLAY BUFFER
01EC   03                     INC   BC   ;INCREMENT DISPLAY BUFFER POINTER
01ED   C9                     RET      ;NIBBLE CONVERSION DONE
01EE                             ; 
01EE                             ;SET DOTS
01EE                             ;THIS ROUTINE SETS THE DOTS IN THE DISPLAY BUFFER. IF IN ADDRESS MODE THEN 4 DOTS ARE SET
01EE                             ;IN THE ADDRESS DISPLAY BUFFER, IF IN A FUNCTION MODE, THEN ONE DOT IN THE ADDRESS DISPLAY
01EE                             ;- RIGHT MOST FOR FUNCTION 1 SECOND RIGHT FOR FUNCTION 2 AND THIRD RIGHT FOR FUNCTION 3.
01EE                             ;IF IN THE DATA MODE THEN 2 DOTS IN THE DATA DISPLAY BUFFER OR ONE DOT, ON THE RIGHTMOST
01EE                             ;DISPLAY, IF TWO NIBBLES HAVE BEEN ENTERED AND IN THE AUTO-INCREMENT MODE.
01EE                J_SETDOTS:      
01EE   06 02                  LD   B,0x02   ;SET B FOR 2 DOTS
01F0   2A 2C 08               LD   HL,(V_DISPLAY)   ;PUT DISPLAY BUFFER IN HL
01F3   3A 2B 08               LD   A,(V_MCB)   ;GET MONITOR CONTROL BYTE (MCB)
01F6   CB 67                  BIT   4,A   ;TEST FOR ADDRESS OR FUNCTION MODE
01F8   28 1A                  JR   Z,L0214   ;JUMP IF NOT TO DO DATA DOTS
01FA   CB 6F                  BIT   5,A   ;TEST ONLY FOR FUNCTION MODE
01FC   20 08                  JR   NZ,L0206   ;JUMP IF FUNCTION MODE
01FE   06 04                  LD   B,4   ;ADDRESS MODE SO SET B FOR 4 DOTS
0200   CB E6        L0200:    SET   4,(HL)   ;SET DOT IN DISPLAY BUFFER
0202   23                     INC   HL   ;NEXT LOCATION
0203   10 FB                  DJNZ   L0200   ;DO 4 TIMES
0205   C9                     RET      ;DONE
0206                             ; 
0206   05           L0206:    DEC   B   ;FUNCTION MODE: SET B FOR ONE DOT
0207   CB 5F                  BIT   3,A   ;TEST FOR FUNCTION 3
0209   20 06                  JR   NZ,L0211   ;JUMP IF FUNCTION 3 TO ADD HL+1
020B   CB 57                  BIT   2,A   ;TEST FOR FUNCTION 2
020D   20 01                  JR   NZ,L0210   ;JUMP IF FUNCTION 2 TO ADD HL+2
020F   23           L020F:    INC   HL   ;INCREMENT HL TO POINT TO THE
0210   23           L0210:    INC   HL   ;REQUIRED DISPLAY BYTE
0211   23           L0211:    INC   HL   ; 
0212   18 EC                  JR   L0200   ;JUMP TO SET DOT
0214   23           L0214:    INC   HL   ;DATA MODE: HL NOW POINTS TO SECOND
0215   4F                     LD   C,A   ;LEFT MOST DISPLAY BUFFER: SAVE MCB
0216   3A 27 08               LD   A,(V_AUTO)   ;IN C: TEST AUTO INCREMENT ENABLE
0219   B7                     OR   A   ;FLAG
021A   20 F3                  JR   NZ,L020F   ;JUMP IF NO AUTO INCREMENT TO SET BOTH
021C   CB 49                  BIT   1,C   ;DATA DOTS: TEST BYTE COUNTER FOR 2
021E   28 EF                  JR   Z,L020F   ;NIBBLES: JUMP IF NOT TO SET BOTH DATA
0220   23                     INC   HL   ;DOTS: ELSE SKIP DOT ON ONE DISPLAY
0221   05                     DEC   B   ;AND DECREASE DOT COUNT FROM 2 TO 1
0222   18 EB                  JR   L020F   ;JUMP TO ADJUST HL AND SET DOTS
0224                             ; 
0224                             ;MASKABLE RESET TONE ROUTINE
0224                             ;IF 0822 IS NOT ZERO THEN NO TONE
0224                J_TONEX2:      
0224   CD 3F 08               CALL   BEEP   ;CALL TONE
0227                             ; 
0227                J_TONE:      
0227                             ;MASKABLE TONE ROUTINE
0227   3A 22 08               LD   A,(V_BEEP)   ;TEST SOUND MASK
022A   B7                     OR   A   ; 
022B   C0                     RET   NZ   ;NO TONE IF NOT ZERO
022C   0E 40                  LD   C,0x40   ;LOAD C WITH PERIOD
022E   2E 31                  LD   L,0x31   ;LOAD L WITH NUMBER OF CYCLES
0230   AF                     XOR   A   ;CLEAR A
0231   D3 01        L0231:    OUT   (DSCAN),A   ;OUT TO SPEAKER
0233   41                     LD   B,C   ; 
0234   10 FE        L0234:    DJNZ   L0234   ;DELAY FOR PERIOD
0236   EE 80                  XOR   0x80   ;TOGGLE SPEAKER BIT
0238   2D                     DEC   L   ;DECREMENT CYCLE COUNT
0239   20 F6                  JR   NZ,L0231   ;LOOP UNTIL ZERO
023B   C9                     RET      ;DONE
023C                             ; 
023C                             ;LCD ROUTINE
023C                             ;IF 0821 IS NOT ZERO, THEN LCD HAS BEEN MASKED OFF BY EITHER THE USER OR THE LCD
023C                             ;INTIALIZER/TESTER ROUTINE AND NO ACTION IS TAKEN ON THE LCD. THE RST 30 (F7) IS USED
023C                             ;EXTENSIVELY TO TEST AND WAIT FOR THE LCD BUSY FLAG. THROUGHOUT THESE NOTES, THE INVISIBLE
023C                             ;INTERNAL CURSOR ON THE LCD IS REFERRED TO AS THE CURSOR, WHILE THE ">" ON THE LCD IS
023C                             ;REFERRED TO AS THE PROMPT.
023C                J_LCD:       
023C   3A 21 08               LD   A,(V_LCD)   ;TEST LCD MASK
023F   B7                     OR   A   
0240   C0                     RET   NZ   ;NOT ZERO = LCD NOT REQUIRED OR FITTED
0241   3E 80                  LD   A,0x80   ;SET LCD CURSOR TO HOME
0243   D3 04                  OUT   (P_LCDINST),A   
0245   F7                     RST   30H   ;WAIT UNTIL LCD READY
0246   CD 53 02               CALL   LCD_LINE1   ;CALL SET-UP AND OUTPUT FIRST LINE
0249   3E C0                  LD   A,0xC0   ;SET CURSOR TO BOTTOM LINE
024B   D3 04                  OUT   (P_LCDINST),A   
024D   F7                     RST   30H   ;WAIT
024E   CD 5A 02               CALL   LCD_LINE2   ;CALL ROUTINE TO OUTPUT BOTTOM LINE
0251   18 33                  JR   LCD_PROMPT   ;JUMP TO PROMPT ROUTINE
0253                             ; 
0253                             ;SET-UP
0253                             ;MODIFY CURRENT EDIT LOCATION ADDRESS IN HL SO THAT IT POINTS TO A BYTE AT AN ADDRESS
0253                             ;ENDING IN EITHER 0 OR 8.
0253                             ; 
0253   2A 2E 08     LCD_LINE1:   LD   HL,(V_CEL)   ;GET CEL AND PUT LOW BYTE IN A
0256   7D                     LD   A,L   ;THEN MASK OFF THE 3 LOWEST BITS
0257   E6 F8                  AND   0xF8   ;AS THE ADDR OF THE FIRST BYTE ON
0259   6F                     LD   L,A   ;THE LCD WILL END WITH 0 OR 8
025A                             ; 
025A                             ;OUTPUT A LINE.  FIRST DISPLAY BASE ADDRESS THEN THE NEXT FOUR BYTES. EG:
025A                             ;   0900>FF AA FF FF
025A                             ;WHERE A RIGHT ARROW WILL BE PLACED ON THE CURRENT ADDRESS BYTE
025A   CD 6C 02     LCD_LINE2:   CALL   HL_2_LCD   ;CALL "HI TO ASCII OUTPUT"
025D   06 04                  LD   B,04   ;SET B FOR 4 BYTES ON A LINE
025F   3E 20        L025F:    LD   A,0x20   ;LOAD A WITH ASCII SPACE
0261   D3 84                  OUT   (P_LCDDATA),A   ;CHARATER AND OUTPUT IT
0263   F7                     RST   30H   ;WAIT
0264   7E                     LD   A,(HL)   ;GET BYTE TO DISPLAY
0265   CD 71 02               CALL   A_2_LCD   ;CONVERT AND OUTPUT IT
0268   23                     INC   HL   ;POINT TO NEXT BYTE
0269   10 F4                  DJNZ   L025F   ;DO FOR 4 BYTES
026B   C9                     RET      ;DONE
026C                             ; 
026C                             ;CONVERT HL TO ASCII (VIA CONVERT A) AND OUTPUT IT
026C   7C           HL_2_LCD:   LD   A,H   ;CONVERT AND
026D   CD 71 02               CALL   A_2_LCD   ;OUTPUT H
0270   7D                     LD   A,L   ;THEN L
0271                             ; 
0271                             ;CONVERT A TO ASCII AND OUTPUT IT
0271   F5           A_2_LCD:   PUSH   AF   ;SAVE A FOR SECOND NIBBLE
0272   0F                     RRCA      ;SHIFT HIGH NIBBLE ACROSS
0273   0F                     RRCA      ; 
0274   0F                     RRCA      ; 
0275   0F                     RRCA      ; 
0276   CD 7A 02               CALL   LCD_NIBBLE   ;CALL NIBBLE CONVERTER
0279   F1                     POP   AF   ;RECOVER LOW NIBBLE
027A   E6 0F        LCD_NIBBLE:   AND   0x0F   ;MASK OFF HIGH NIBBLE
027C   C6 90                  ADD   A,0x90   ;CONVERT TO
027E   27                     DAA      ;ASCII
027F   CE 40                  ADC   A,0x40   ;USING THIS
0281   27                     DAA      ;AMAZING ROUTINE
0282   D3 84        LCD_OUT:   OUT   (P_LCDDATA),A   ;OUTPUT IT
0284   F7                     RST   30H   ;WAIT
0285   C9                     RET      ;DONE
0286                             ; 
0286                             ;LCD PROMPT AND MODE WORD OUTPUT
0286                             ;THE 3 LOWEST BITS OF THE CURRENT EDIT LOCATION (CEL) ARE USED AS A DISPLACEMENT WHICH IS
0286                             ;ADDED TO A TABLE BASE. THE TABLE ENTRIES ARE THE LCD ADDRESSES OF THE PROMPT LOCATIONS.
0286                             ;IF THE AUTO INCREMENT MODE IS ON AND 2 NIBBLES HAVE BEEN ENTERED, THE DISPLACEMENT IS
0286                             ;INCREMENTED SO THAT THE NEXT PROMPT ADDRESS TABLE ENTRY WILL BE ACCESSED TO MOVE THE
0286                             ;PROMPT TO ITS NEXT SCREEN LOCATION. THE TABLE IS 9 ENTRIES LONG. 8 ARE FOR THE SPACES
0286                             ;BETWEEN THE DATA BYTES AND THE NINTH IS TO PARK THE PROMPT AT THE TOP LEFT-HAND CORNER
0286                             ;WHEN A SCREEN CHANGE IS DUE
0286                             ; 
0286   3A 2E 08     LCD_PROMPT:   LD   A,(V_CEL)   ;GET LOW BYTE OF CEL
0289   E6 07                  AND   0x07   ;MASK IT DOWN TO THE 3 LOWEST BITS
028B   4F                     LD   C,A   ;SAVE IN C
028C   3A 27 08               LD   A,(V_AUTO)   ;TEST FOR AUTO INCREMENT MODE
028F   B7                     OR   A   ;O=ON
0290   3A 2B 08               LD   A,(V_MCB)   ;GET MCB
0293   57                     LD   D,A   ;PUT MCB IN D
0294   20 05                  JR   NZ,L029B   ;JUMP IF AUTO INCREMENT MODE OFF
0296   CB 4F                  BIT   1,A   ;TEST FOR 2 NIBBLES ENTERED: JUMP
0298   28 01                  JR   Z,L029B   ;IF NOT: ELSE INCREMENT
029A   0C                     INC   C   ;DISPLACEMENT TO ADVANCE TO
029B   79           L029B:    LD   A,C   ;NEXT PROMPT LOCATION ADDRESS
029C   21 BD 07               LD   HL,LCDPMT_TBL   ;LOAD HL WITH BASE OF PROMPT
029F   85                     ADD   A,L   ;TABLE AND ADD DISPLACEMENT
02A0   6F                     LD   L,A   ;PUT LOW BYTE OF TABLE ADDRESS
02A1   7E                     LD   A,(HL)   ;IN L AND GET PROMPT ADDRESS IN A
02A2   D3 04                  OUT   (P_LCDINST),A   ;AND OUTPUT PROMPT ADDRESS TO LCD
02A4   F7                     RST   30H   ;WAIT
02A5   3E 3E                  LD   A,0x3E   ;LOAD A WITH ASCII FOR ">"
02A7   D3 84                  OUT   (P_LCDDATA),A   ;OUTPUT PROMPT
02A9   F7                     RST   30H   ;WAIT
02AA                             ; 
02AA                             ;OUTPUT MODE WORD TO BOTTOM LEFT CORNER OF THE LCD.
02AA                             ;IF THE MODE IS EITHER DATA OR ADDR, THEN THE FOUR ASCII BYTES ARE OUTPUTTED. IF IN THE
02AA                             ;FUNCTION MODE, THEN ONLY THREE BYTES FROM THE TABLE ARE OUTPUTTED AND THEN THE FUNCTION
02AA                             ;NUMBER IS CALCULATED AND OUTPUTTED.
02AA                             ;NOTICE THAT FROM THE TABLE BASE THE FIRST ENTRY (DATA) HAS A ZERO DISPLACEMENT WHILE THE
02AA                             ;SECOND (ADDR) HAS A DISPLACEMENT OF 4 AND THE THIRD (Fs-) HAS A DISPLACEMENT OF 12.
02AA                             ;IF YOU LOOK AT THE TABLE AT 07AD, YOU WILL SEE THAT IT IS STAGGERED WITH THE THIRD ENTRY
02AA                             ;12 BYTES AWAY FROM THE BASE.
02AA                             ; 
02AA   3E C0                  LD   A,0xC0   ;SET CURSOR TO BOTTOM LINE
02AC   D3 04                  OUT   (P_LCDINST),A   ;OUTPUT
02AE   F7                     RST   30H   ;AND WAIT
02AF   7A                     LD   A,D   ;PUT MONITOR CONTROL BYTE (MCB) IN A
02B0   0F                     RRCA      ;SHIFT MODE BITS TO BITS 2 AND 3
02B1   0F                     RRCA      ;TO USE AS TABLE DISPLACEMENT
02B2   57                     LD   D,A   ;SAVE IN D AND MASK OFF ALL BITS
02B3   E6 0C                  AND   0x0C   ;EXCEPT THE 2 THAT FLAG BETWEEN DATA,
02B5   21 AD 07               LD   HL,LCDFNC_TBL   ;ADDR AND FUNCTION: A=0 IF DATA, 4 IF
02B8   85                     ADD   A,L   ;ADDR, 12 IF FUNCTION, NOTE THAT TABLE
02B9   6F                     LD   L,A   ;IS STAGGERED (SEE 07AD): ADD A TO BASE
02BA   FE B9                  CP   0xB9   ;IF A=B9 THEN MODE IS FUNCTION MODE
02BC   01 84 04               LD   BC,0484H   ;LOAD C WITH PORT, B WITH BYTE COUNT
02BF   28 06                  JR   Z,L02C7   ;JUMP IF FUNCTION MDDE TO OUT 3 BYTES
02C1   ED A3        L02C1:    OUTI      ;OUT (HL) TO (C) B=B-1
02C3   F7                     RST   30H   ;HL=HL+1: WAIT FOR LCD BUSY FLAG
02C4   20 FB                  JR   NZ,L02C1   ;LOOP UNTIL B=0
02C6   C9                     RET      ;DONE
02C7                             ; 
02C7   06 03        L02C7:    LD   B,0x03   ;ONLY THREE BYTES FOR FUNCTION MODE
02C9   CD C1 02               CALL   L02C1   ;CALL THE OUTPUT ROUTINE ABOVE
02CC   7A                     LD   A,D   ;PUT MCB (SHIFTED RIGHT TWICE) IN A
02CD   E6 03                  AND   0x03   ;MASK IT DOWN TO GET JUST THE FUNCTION
02CF   C6 31                  ADD   A,0x31   ;NUMBER BITS: ADD ASCII "1"
02D1   18 AF                  JR   LCD_OUT   ;JUMP TO OUTPUT FUNCTION NUMBER
02D3                             ; 
02D3                             ;-END OF MONITOR ROUTINES- (EXCEPT KEYBOARD READER AT 06AD)
02D3                             ; 
02D3                             ;LCD PROMPT MOVING ROUTINES. (SHIFT AND FUNCTION 1)
02D3                             ;THESE ROUTINES ALTER THE CURRENT EDIT LOCATION ADDRESS AND STORE IT IN ITS BUFFER. WHEN
02D3                             ;THE RETURN IS DONE, JMON IS RE-ENTERED AT 00132 (VIA THE SOFT RE-ENTRY JUMP AT L0845, THE
02D3                             ;ADDRESS OF WHICH HAS BEEN PLACED ON THE STACK BY PART OF THE "GO" ROUTINE).
02D3   11 04 00     FN_FORW4:   LD   DE,0x0004   ;DE= +4
02D6   2A 2E 08     L02D6:    LD   HL,(V_CEL)   ;PUT CEL IN HL
02D9   19                     ADD   HL,DE   ;ADD TO GET NEW CEL
02DA   22 2E 08               LD   (V_CEL),HL   ;STORE IN CEL BUFFER
02DD   C9                     RET      ;DONE
02DE                             ; 
02DE   11 FC FF     FN_BACK4:   LD   DE,0xFFFC   ;DE= -4
02E1   18 F3                  JR   L02D6   ;JUMP TO ADD
02E3   11 FF FF     FN_BACK1:   LD   DE,0xFFFF   ;DE= -1
02E6   18 EE                  JR   L02D6   ;JUMP TO ADD
02E8   11 01 00     FN_FORW1:   LD   DE,0x0001   ;DE= +1
02EB   18 E9                  JR   L02D6   ;JUMP TO ADD
02ED   11 08 00     FN_FORW8:   LD   DE,0x0008   ;DE= +8
02F0   18 E4                  JR   L02D6   ;JUMP TO ADD
02F2   11 F8 FF     FN_BACK8:   LD   DE,0xFFF8   ;DE= -8
02F5   18 DF                  JR   L02D6   ;JUMP TO ADD
02F7                             ; 
02F7                             ;RESET PATCH CHECKER.
02F7                             ;TESTS FOR PATCH REQUIREMENT AND UP TO THE FIRST 256 BYTES OF THE PATCH ROUTINE. THE
02F7                             ;CHECKSUM FEATURE ENSURES A WAY TO CHECK THAT THE PATCH OR PATCH VARIABLES HAVE NOT BEEN
02F7                             ;CORRUPTED BY A SYSTEM CRASH, OTHERWISE YOU MAY NEVER REGAIN CONTROL OF THE COMPUTER UNLESS
02F7                             ;YOU TURN IT OFF, (AND LOSE THE CONTENTS OF YOUR MEMORY - YOU CANNOT RECOVER IT BY A FORCED
02F7                             ;HARD RESET AS THE USER PATCH IS EXECUTED BEFORE THE FORCED HARD RESET TEST). (A FORCED
02F7                             ;HARD RESET IS WHEN A KEY IS HELD DOWN WHEN THE RESET KEY IS RELEASED).
02F7                             ;IF YOU HAVE A NON VOLATILE MEMORY AT 0800 THE SITUATION WOULD BE ABSOLUTELY HOPELESS
02F7                             ;WITHOUT THIS CHECKER ROUTINE.
02F7                             ;A VARIABLE CAN BE PASSED TO YOUR PATCH ROUTINE IN THE "C" REGISTER. TO DO THIS THE VARIABLE
02F7                             ;IS PLACED AT ADDRESS LOCATION 08B3.
02F7                             ; 
02F7   3A B0 08     RST_PATCH:   LD   A,(PATCH_REQ)   ;TEST FOR RESET PATCH REQUIRED
02FA   FE AA                  CP   0xAA   
02FC   C0                     RET   NZ   ;RETURN IF NOT
02FD   ED 4B B3 08            LD   BC,(PATCH_VAR)   ;PUT NO OF BYTES IN B VARIABLE IN C
0301   2A B1 08               LD   HL,(PATCH_STA)   ;START IN HL
0304   AF                     XOR   A   ;CLEAR A
0305   86           L0305:    ADD   A,(HL)   ;ADD CHECKSUM
0306   23                     INC   HL   
0307   10 FC                  DJNZ   L0305   ;UNTIL B=0
0309   21 B5 08               LD   HL,PATCH_CHK   ;POINT TO REQUIRED CHECKSUM
030C   BE                     CP   (HL)   ;TEST FOR EQUAL
030D   C0                     RET   NZ   ;ABORT IF NOT
030E   2A B6 08               LD   HL,(PATCH_ADR)   ;ELSE GET START ADDR
0311   E9                     JP   (HL)   ;AND DO RESET PATCH
0312                             ; 
0312                             ;STEPPER ROUTINE
0312                             ;THE STEPPER ROUTINE IS BROKEN UP INTO SEVERAL SECTIONS. THE FIRST IS THE REGISTER SAVE,
0312                             ;WHERE ALL THE Z80 USER REGISTERS ARE STORED IN MEMORY.
0312                             ; 
0312   22 70 08     STEPPER:   LD   (STEP_HL),HL   ;STORE HL IN ITS REGISTER STACK SPOT
0315   21 44 03               LD   HL,STEP_CONT   ;LOAD HL WITH RETURN ADDRESS - Was 0x0344
0318                             ; 
0318                             ;MONITOR JUMPS TO HERE ON RESET TO PRESERVE USER REGISTERS.
0318   22 60 08     SAVE_REGS:   LD   (RE_ENTRY),HL   ;STORE RE-ENTRY ADDRESS IN BUFFER
031B   2A 58 08               LD   HL,(STEP_NEXT)   ;GET ADDRESS OF INSTRUCTION JUST
031E   22 68 08               LD   (STEP_PREV),HL   ;STEPPED AND PUT IT IN "NEXT PC"
0321   ED 73 7E 08            LD   (STEP_SP),SP   ;BUFFER: SAVE STACK POINTER VALUE
0325   E1                     POP   HL   ;GET RETURN ADDR, THIS IS THE ADDRESS
0326   22 58 08               LD   (STEP_NEXT),HL   ;OF NEXT BYTE TO STEP: STORE IN
0329   31 7E 08               LD   SP,STEP_SP   ;"NEXT PC" BUFFER: LOAD REGISTER DUMP
032C   08                     EX   AF,AF'   ;STACK: PUSH ALTERNATE REGISTERS
032D   D9                     EXX      ;FIRST
032E   E5                     PUSH   HL   ;SAVE ALL REGISTERS
032F   D5                     PUSH   DE   
0330   C5                     PUSH   BC   
0331   F5                     PUSH   AF   
0332   FD E5                  PUSH   IY   
0334   DD E5                  PUSH   IX   
0336   08                     EX   AF,AF'   
0337   D9                     EXX      
0338   3B                     DEC   SP   
0339   3B                     DEC   SP   
033A   D5                     PUSH   DE   
033B   C5                     PUSH   BC   
033C   F5                     PUSH   AF   
033D   2A 60 08               LD   HL,(RE_ENTRY)   ;RE-ENTER CALLING ROUTINE VIA
0340   E9                     JP   (HL)   ;THE ADDRESS IT SUPPLIED AT 0860
0341                FN_REGDIS:      
0341   31 6A 08               LD   SP,STEP_REGS   ;SHIFT 7 ROUTINE START (REG DISPLAY)
0344                             ; 
0344                             ;THE REGISTERS HAVE BEEN SAVED. NOW THE DISPLAY AND KEYBOARD HANDLER IS SET UP. THE STACK
0344                             ;IS DECREMENTED BY TWO TO POINT TO THE "PC" BUFFER. THE ADDRESS IN THE "PC" BUFFER IS THE
0344                             ;ADDRESS OF THE INSTRUCTION JUST STEPPED.
0344                             ;THE NUMBER OF THE FIRST REGISTER (1 FOR "PC") IS PUT INTO THE CURRENT REGISTER NUMBER
0344                             ;BUFFER.
0344                             ; 
0344   21 06 08     STEP_CONT:   LD   HL,DISP_STEP   ;CREATE NEW DISPLAY BUFFER
0347   22 2C 08               LD   (V_DISPLAY),HL   ; 
034A   3B                     DEC   SP   ;DECREASE SP BY 2 TO POINT TO THE
034B   3B                     DEC   SP   ;"PC" BUFFER
034C                             ; 
034C                             ;WHEN UP-DATING THE DISPLAY, THE ROUTINE MAY JUMP BACK TO HERE IF THE FIRST DISPLAY IS REQUIRED.
034C   3E 01        L034C:    LD   A,0x01   ;SET UP FOR THE FIRST REGISTER (PC)
034E   32 5A 08               LD   (STEP_CREG),A   ;DISPLAY
0351                             ; 
0351                             ;OR HERE IF IT HAS ALTERED THE CURRENT REGISTER NUMBER IN ITS STORAGE LOCATION (085A).
0351   3A 5A 08     L0351:    LD   A,(STEP_CREG)   ;DISPLAY LOOP STARTS HERE
0354                             ; 
0354                             ;HL IS LOADED WITH THE STACK POINTER VALUE, (WHICH POINTS TO THE "PC" BUFFER), MINUS TWO.
0354                             ;THE TWO IS SUBTRACTED BECAUSE AN EXTRA TWO WILL BE ADDED TO HL DURING THE REGISTER BUFFER
0354                             ;CALCULATOR (IMMEDIATELY BELOW) AS THE NUMBER OF THE FIRST REGISTER IS 1 AND NOT ZERO.
0354   21 FE FF               LD   HL,0xFFFE   ;HL=-2
0357   39                     ADD   HL,SP   ;HL=SP-2
0358   23           L0358:    INC   HL   ;INCREMENT HL TO POINT TO THE
0359   23                     INC   HL   ;CURRENT REGISTER BUFFER
035A   3D                     DEC   A   ;INDICATED BY THE NUMBER IN A
035B   20 FB                  JR   NZ,L0358   
035D                             ; 
035D                             ;HL NOW POINTS TO THE CURRENT REGISTER BUFFER. THIS SECTION PUTS THE REGISTER(S) CONTENT(S)
035D                             ;INTO HL AND CONVERTS IT TO DISPLAY CODE AND STORE THE DISPLAY CODE IN THE DISPLAY BUFFER.
035D                             ; 
035D   7E                     LD   A,(HL)   ;GET 16 BIT VALUE
035E   23                     INC   HL   ;AND PUT IT
035F   66                     LD   H,(HL)   ;BACK INTO
0360   6F                     LD   L,A   ;HL
0361   ED 4B 2C 08            LD   BC,(V_DISPLAY)   ;PUT DISPLAY BUFFER ADDRESS IN BC
0365   CD 30 08               CALL   HL_2_DIS   ;CALL HL TO DISPLAY CODE ROUTINE
0368                             ; 
0368                             ;THIS SECTION CALCULATES THE ADDRESS OF THE REGISTER NAME FOR THE DATA DISPLAYS. THESE
0368                             ;ARE STORED IN A TABLE. THE REQUIRED REGISTER NAME IS THEN TRANSFERRED TO THE DISPLAY
0368                             ;BUFFER.
0368                             ; 
0368   3A 5A 08               LD   A,(STEP_CREG)   ;GET REGISTER NUMBER
036B   C5                     PUSH   BC   ;PUT NEXT DISPLAY BUFFER
036C   D1                     POP   DE   ;LOCATION INTO DE(stination)
036D   01 02 00               LD   BC,0x0002   ;BC IS THE NUMBER OF DATA DISPLAYS
0370   21 92 07               LD   HL,REG_TBL   ;HL=THE BASE OF THE NAME TABLE (MINUS 2)
0373   09           L0373:    ADD   HL,BC   ;ADD TO HL 2 FOR EACH
0374   3D                     DEC   A   ;REGISTER NUMBER TO ACCESS THE
0375   20 FC                  JR   NZ,L0373   ;CURRENT REGISTER NAME
0377   ED B0                  LDIR      ;MOVE REGISTER NAME INTO RAM
0379                             ; 
0379                             ;THE SCAN AND KEYBOARD ROUTINE ARE NOW CALLED (VIA THE RST 18). IF A VALID KEY IS PRESSED,
0379                             ;THEN THE ZERO FLAG IS SET WHEN THE RST RETURNS.
0379                             ; 
0379   DF           STEP_DISP:   RST   18H   ;SCAN/KEY READ RST
037A   21 24 08               LD   HL,V_STEP_TMR   ;(HL)=AUTO STEP CONTROL/TIMER BYTE
037D   28 0B                  JR   Z,STEP_KEY   ;JUMP IF VALID KEY PRESSED
037F                             ; 
037F                             ;NO KEY IS PRESSED SO THE ROUTINE CHECKS FOR THE AUTO REPEAT MODE ENABLED FLAG (BIT 7 AUTO
037F                             ;STEP CONTROL/TIMER BYTE, ZERO IS AUTO STEP ENABLED) AND DECREMENTS THE COUNTER IF IT IS.
037F                             ;IF THE COUNTER REACHES ZERO, THEN IT IS RELOADED AND THE ROUTINE JUMPS TO RECOVER THE
037F                             ;REGISTERS AND STEP THE NEXT INSTRUCTION. IF NOT IN THE AUTO MODE OR THE COUNTER DOES NOT
037F                             ;REACH ZERO, THEN THE ROUTINE LOOPS BACK TO SCAN THE DISPLAY AND WAIT FOR EITHER A KEY
037F                             ;PRESS OR FOR THE COUNTER TO REACH ZERO.
037F                             ; 
037F   CB 7E                  BIT   7,(HL)   ;TEST FOR AUTO INCREMENT JUMP IF NOT
0381   20 F6                  JR   NZ,STEP_DISP   ;ENABLED TO SCAN/KEY READ LOOP
0383   35                     DEC   (HL)   ;DECREMENT COUNTER: LOOP TO
0384   20 F3                  JR   NZ,STEP_DISP   ;SCAN/KEY READ UNTIL COUNT=0
0386                             ; 
0386                             ;AT THIS POINT THE AUTO-STEP DELAY HAS REACHED ZERO AND IS RELOADED WITH THE DELAY VALUE.
0386                             ;A JUMP IS THEN DONE TO RECOVER THE REGISTERS AND STEP THE NEXT INSTRUCTION.
0386   36 30                  LD   (HL),0x30   ;RESET AUTO STEP DELAY, JUMP TO RECOVER
0388   18 22                  JR   STEP_DO_GO   ;REGISTERS AND STEP NEXT INSTRUCTION
038A                             ; 
038A                             ;KEY PROCESSING STARTS HERE
038A                             ;THE AUTO-STEP IS DISABLED AND THEN THE KEY IS IDENTIFIED AND HANDLED.
038A                             ;THE AUTO-STEP WILL BE RE-ENABLED IF THE KEY PRESSED IS A DATA KEY.
038A                             ; 
038A   47           STEP_KEY:   LD   B,A   ;SAVE KEY
038B   36 FF                  LD   (HL),0xFF   ;SET AUTO STEP CONTROL/TIMER BIT 7
038D   21 5A 08               LD   HL,STEP_CREG   ;THUS DISABLING THE AUTO REPEAT MODE
0390   78                     LD   A,B   ;POINT HI, TO CURRENT REG No. BUFFER
0391   FE 10        STEP_PLUS:   CP   K_PLUS   ;PUT INPUT IN A,TEST IT FOR "+"
0393   20 08                  JR   NZ,STEP_MINUS   ;JUMP IF NOT TO TEST FOR "-"
0395                             ; 
0395                             ;"+" KEY HANDLER
0395                             ;THE CURRENT REGISTER NUMBER IS INCREMENTED AND THEN CHECK TO SEE THAT IT HAS NOT EXCEEDED
0395                             ;THE HIGHEST REGISTER NUMBER (OC). IF IT HAS, THE ROUTINE JUMPS TO RESET THE CURRENT
0395                             ;REGISTER NUMBER WITH 1, OTHERWISE IT JUMPS TO THE DISPLAY LOOP.
0395                             ; 
0395   34                     INC   (HL)   ;INCREMENT REGISTER NUMBER
0396   7E                     LD   A,(HL)   ;AND CHECK TO SEE IF IT LARGER
0397   FE 0D                  CP   0x0D   ;THAN HIGHEST REG No. (0C): IF LOWER
0399   38 B6                  JR   C,L0351   ;THAN OD JUMP TO DISPLAY LOOP ELSE
039B   18 AF                  JR   L034C   ;JUMP TO SET REGISTER NUMBER TO 1
039D                             ; 
039D   FE 11        STEP_MINUS:   CP   K_MINUS   ;TEST FOR "-"
039F   20 07                  JR   NZ,STEP_GO   ;JUMP IF NOT
03A1                             ; 
03A1                             ;"-" HANDLER
03A1                             ;ONE IS TAKEN FROM THE CURRENT REGISTER NUMBER AND THEN IT IS CHECKED FOR ZERO. IF IT
03A1                             ;BECOMES ZERO, THEN THE CURRENT REGISTER NUMBER IS SET TO THE HIGHEST REGISTER NUMBER (OC)
03A1                             ;TO WRAP-AROUND TO DISPLAY THE LAST REGISTER.
03A1   35                     DEC   (HL)   ;SUBTRACT 1 FROM REGISTER NUMBER
03A2   20 AD                  JR   NZ,L0351   ;JUMP IF NOT 0 TO UP-DATE DISPLAY
03A4   36 0C                  LD   (HL),0x0C   ;ELSE SET TO LAST REGISTER
03A6   18 A9                  JR   L0351   ;AND UP-DATE
03A8                             ; 
03A8                             ;TEST FOR "GO"
03A8   FE 12        STEP_GO:   CP   K_GO   ;TEST FOR "GO" AND JUMP IF NOT
03AA   20 1A                  JR   NZ,STEP_AD   ;TO TEST FOR "AD" OR DATA KEY
03AC                             ; 
03AC                             ;"GO" KEY
03AC                             ;THE GO KEY CAUSES STEPPING EXECUTION TO CONTINUE.
03AC                             ;BEFORE STEPPING IS CONTINUED THOUGH, THE KEYBOARD IS READ AND THE PROGRAM LOOPS UNTIL
03AC                             ;ALL KEYS ARE RELEASED. THIS IS TO SEPARATE KEY PRESSES MEANT FOR THE STEPPER AND THOSE
03AC                             ;FOR THE ROUTINE BEING STEPPED. ONCE ALL KEYS ARE RELEASED, ALL THE REGISTERS ARE POPPED
03AC                             ;OF THE REGISTER DISPLAY STACK, THE STACK IS RESTORED TO ITS "REAL" POSITION AND THE
03AC                             ;INTERRUPTS RE-ENABLED. THE RETURN ADDRESS FOR THE ROUTINE BEING STEPPED, STILL THERE ON
03AC                             ;THE TOP OF THE REAL STACK, IS USED AS THE RETURN ADDRESS.
03AC                             ; 
03AC   E7           STEP_DO_GO:   RST   20H   ;WAIT UNTIL ALL KEYS ARE RELEASED
03AD   28 FD                  JR   Z,STEP_DO_GO   ;BEFORE RESTARTING
03AF   E1                     POP   HL   ;RECOVER ALL
03B0   F1                     POP   AF   ;REGISTERS
03B1   C1                     POP   BC   ;IN
03B2   D1                     POP   DE   ;THE
03B3   E1                     POP   HL   ;REVERSE
03B4   DD E1                  POP   IX   ;ORDER
03B6   FD E1                  POP   IY   ;TO
03B8   08                     EX   AF,AF'   ;HOW
03B9   D9                     EXX      ;THEY
03BA   F1                     POP   AF   ;STORED
03BB   C1                     POP   BC   
03BC   D1                     POP   DE   
03BD   E1                     POP   HL   
03BE   08                     EX   AF,AF'   
03BF   D9                     EXX      
03C0   ED 7B 7E 08            LD   SP,(STEP_SP)   ;AND STACK POINTER
03C4   FB                     EI      ;RE-ENABLE THE INTERRUPTS
03C5   C9                     RET      ;RET TO STEP NEXT INSTRUCTION
03C6                             ; 
03C6                             ;TEST FOR "AD" KEY (RETURN TO JMON)
03C6   FE 13        STEP_AD:   CP   K_ADDR   ;TEST FOR "ADDR" KEY
03C8   20 01                  JR   NZ,STEP_DATA   ;JUMP IF NOT TO ASSUME DATA KEY
03CA   C7                     RST   00H   ;RETURN TO MONITOR
03CB                             ; 
03CB                             ;DATA KEY HANDLER (ENABLE AUTO STEP)
03CB   3E 20        STEP_DATA:   LD   A,0x20   ;SET AND ENABLE AUTO STEP IN THE
03CD   32 24 08               LD   (V_STEP_TMR),A   ;CONTROL/TIMER BYTE (BIT 7 LOW, 20
03D0   18 A7                  JR   STEP_DISP   ;CYCLES): JUMP TO DISPLAY LOOP
03D2                             ;-END OF STEPPER-
03D2                             ; 
03D2                             ;START OF MENU
03D2                             ;MENU IS SET-UP FOR TAPE ROUTINE HERE
03D2                             ;THE VARIABLES ARE MOVED FROM ROM TO RAM AND THE DISPLAY BUFFER IS SET TO 0800.
03D2                             ; 
03D2                             ;AS THE MENU IS PRIMARILY USED FOR THE TAPE COMPONENT IT ENTRY IS PLACED PRIOR TO THE MENU
03D2                             ;DRIVER.  BUT THE MENU CAN BE USED ANYWHERE PROVIDED THAT MENU VARIABLES ARE SET UP AT 0x880
03D2                FN_TAPE:      
03D2   21 7C 07               LD   HL,TAPE_P_DRIVER   ;LOAD HL WITH START OF TAPE
03D5   11 80 08               LD   DE,PERI_MENU   ;VARIABLES: DE IS RAM DE(stination)
03D8   01 18 00               LD   BC,0018H   ;BC IS THE COUNT
03DB   ED B0                  LDIR      ;SHIFT VARIABLES
03DD   21 00 08     MENU_RTN:   LD   HL,DISP_BUFF   ;PUT DISPLAY BUFFER AT 0800
03E0   22 2C 08               LD   (V_DISPLAY),HL   
03E3                             ; 
03E3                             ;MENU DISPLAY LOOP STARTS HERE
03E3                             ;THE MENU ENTRY NUMBER (MEN), HOLDS THE NUMBER OF THE CURRENT MENU ENTRY ON THE DISPLAY.
03E3                             ;ALL ACTIONS OF THE MENU DRIVER CENTRE AROUND THIS BYTE.
03E3                             ;THE DISPLAY ON THE TEC LED DISPLAY IS GENERATED BY SHIFTING BOTH THE DATA AND ADDRESS
03E3                             ;DISPLAY CODES INTO THE RAM DISPLAY BUFFER.
03E3                             ;ALL THE POSSIBLE DATA AND ADDRESS DISPLAY CODES ARE STORED IN SEPARATE TABLES IN ROM,
03E3                             ;THE BASE OF EACH IS ADDRESSED BY THE CONTENTS OF MEMORY LOCATIONS 0895 (DATA TABLE), AND
03E3                             ;0893 (ADDRESS TABLE).
03E3                             ;THE FIRST MENU ENTRY IS DENOTED BY A ZERO VALUE IN THE MENU ENTRY NUMBER (MEN). THIS
03E3                             ;MEANS THAT THE POSSIBLE ZERO CONDITION MUST BY DETECTED AND THE TABLE ENTRY CALCULATOR
03E3                             ;SECTION SKIPPED OVER. WHEN ACCESSING THE DISPLAY TABLES, THE MENU ENTRY NUMBER IS
03E3                             ;DECREMENTED UNTIL ZERO AND EACH TIME AN OFFSET EQUAL TO THE LENGTH OF EACH TABLE ENTRY
03E3                             ;(4 FOR ADDR AND 2 FOR DATA TABLES) IS ADDED TO THE POINTERS.
03E3                             ;AFTER THE REQUIRED ENTRIES ARE FOUND, THEY ARE MOVED INTO THE RAM DISPLAY BUFFER.
03E3                             ; 
03E3   3A 8F 08     MENU_DISP:   LD   A,(MENU_NO)   ;GET MENU ENTRY NUMBER (MEN)
03E6   ED 5B 95 08  MENU_RTNT:   LD   DE,(MENU_D_TBL)   ;DE POINTS TO DATA DISPLAY TABLE
03EA   2A 93 08               LD   HL,(MENU_A_TBL)   ;HL POINTS TO ADDR DISPLAY TABLE
03ED   01 04 00     MENU_SFT:   LD   BC,0004H   ;BC IS BOTH AN INDEX OFFSET AND
03F0   B7                     OR   A   ;BYTE COUNTER (USED BELOW): TEST
03F1   28 06                  JR   Z,L03F9   ;A AND SKIP CALCULATOR IF ZERO
03F3   09           L03F3:    ADD   HL,BC   ;ADD 4 TO HL TO POINT TO NEXT ADDR
03F4   13                     INC   DE   ;DISPLAY AND 2 TO DE FOR NEXT DATA
03F5   13                     INC   DE   ;DISPLAY
03F6   3D                     DEC   A   ;DO UNTIL A=0
03F7   20 FA                  JR   NZ,L03F3   
03F9   E5           L03F9:    PUSH   HL   ;SAVE ADDR POINTER (not required)
03FA   D5                     PUSH   DE   ;AND DATA POINTER
03FB   11 00 08               LD   DE,DISP_BUFF   ;SHIFT ACROSS ADDR DISPLAY
03FE   ED B0                  LDIR      ;TO 0800 (BC-0004 FROM ABOVE)
0400   E1                     POP   HL   ;POP (DE) DATA DISPLAY ADDR INTO HL
0401   0E 02                  LD   C,0x02   ;SET PC TO SHIFT DATA DISPLAY BYTES
0403   ED B0                  LDIR      ;SHIFT THE BYTES TO DISPLAY RAM
0405   E1                     POP   HL   ;CLEAN UP STACK
0406                             ; 
0406                             ;THIS SECTION CALLS THE SCAN/KEY/LCD/PATCH ROUTINE.
0406                             ;WHEN A KEY IS DETECTED A KEY HANDLER ROUTINE IS CALLED. THIS KEY HANDLER IS COMMON TO
0406                             ;BOTH THE MENU DRIVER AND THE PERIMETER HANDLER AND IS DOCUMENTED ON FURTHER.
0406                             ;IF THE "GO" KEY WAS PRESSED, THE ZERO FLAG WILL BE SET WHEN THE COMMON KEY HANDLER RETURNS
0406                             ;AND THE ROUTINE JUMPS TO THE GO HANDLER. IF NOT, THEN A (UNUSED BY JMON) ROUTINE (AT
0406                             ;0897) IS CALLED AND FINDS AN IMMEDIATE RETURN.
0406                             ;THE RETURN INSTRUCTION WAS PLACED AT 0897 WHEN THE TAPE'S MENU VARIABLES WERE SHIFTED
0406                             ;FROM ROM TO RAM (SEE 0793).
0406                             ;A JUMP THEN LOOPS BACK TO THE MAIN DISPLAY LOOP TO UP-DATE THE DISPLAYS IN CASE OF A NEW
0406                             ;MENU ENTRY NUMBER (MEN) BEING PROVIDED BY THE KEY HANDLER.
0406                             ;THE GO HANDLER IS A SIMPLE TABLE ENTRY CALCULATOR THAT USES THE MENU ENTRY NUMBER TO
0406                             ;INDEX THROUGH A TABLE OF THREE BYTE JUMPS. LIKE THE DISPLAY CALCULATOR, THE ZERO POSSIBILITY
0406                             ;IS TESTED FOR AND THE CALCULATOR SECTION IS SKIPPED OVER IF ZERO. WHEN THE REQUIRED TABLE
0406                             ;ENTRY IS POINTED TO BY HL, IT IS THEN JUMPED TO VIA JP (HL), AND THE TABLE ENTRY,,,ITSELF
0406                             ;BEING A 3 BYTE JUMP THEN JUMPS TO THE SELECTED MENU ENTRY'S ROUTINE.
0406                             ; 
0406   CD 42 08               CALL   SCAN_IO   ;CALL SCAN/KEY/LCD/PATCH ROUTINE
0409   21 8F 08               LD   HL,MENU_NO   ;POINT HL TO MENU ENTRY NUMBER
040C   CD B2 04               CALL   MENU_KEY   ;CALL COMMON KEY HANDLER
040F   28 05                  JR   Z,MENU_GO   ;JUMP IF KEY WAS "GO" ELSE CALL TO
0411   CD 97 08               CALL   MENU_KEYRN   ;RETURN INSTRUCTION (UNUSED BY JMON)
0414   18 CD                  JR   MENU_DISP   ;LOOP TO MAIN DISPLAY LOOP
0416                             ; 
0416                             ;MENU "GO" KEYHANDLER
0416   2A 91 08     MENU_GO:   LD   HL,(MENU_J_TBL)   ;POINT HL TO BASE OF JUMP TABLE
0419   3A 8F 08               LD   A,(MENU_NO)   ;GET MENU ENTRY NUMBER
041C   B7                     OR   A   ;TEST FOR ZERO
041D   28 06                  JR   Z,L0425   ;SKIP CALCULATOR IF ZERO
041F   23           L041F:    INC   HL   ;FIND JUMP VECTOR FOR THE CURRENT
0420   23                     INC   HL   ;MENU HEADING
0421   23                     INC   HL   
0422   3D                     DEC   A   
0423   20 FA                  JR   NZ,L041F   
0425   E9           L0425:    JP   (HL)   ;AND JUMP TO THE REQUIRED ROUTINE
0426                             ; 
0426                             ;PERIMETER HANDLER SET-UP ROUTINES FOR THE TAPE SOFTWARE
0426                             ;WHEN GO IS PRESSED IN THE MENU HANDLER, ONE OF THE IMMEDIATE FOLLOWING ROUTINES IS EXECUTED
0426                             ;(WHEN THE MENU IS WORKING WITH THE TAPE SOFTWARE). THESE ROUTINES SET-UP THE VARIABLES
0426                             ;FOR THE MAIN TAPE FUNCTIONS (SAVE, TEST CS, TEST BL AND LOAD). THE TWO TESTS AND THE LOAD
0426                             ;ROUTINE IS BASICALLY THE ONE ROUTINE, EXCEPT THAT EACH HAS ITS OWN PRIVATE SIGN-ON BYTE.
0426                             ;LATER YOU WILL SEE THE THE ROUTINE TO LOAD OR TEST IS BASICALLY THE SAME AND THIS "SIGN-ON
0426                             ;BYTE" SEPARATES THE DIFFERENT FUNCTIONS AT THE CRITICAL STAGE.
0426                             ;THE COMMON SECTION FOR THE LOAD AND TESTS, SETS THE PERIMETER HANDLER TO HAVE TWO WINDOWS,
0426                             ;ONE FOR THE FILE NUMBER AND ONE FOR THE OPTIONAL START ADDRESS. IT ALSO SETS THE OPTIONAL
0426                             ;START WINDOW TO FFFF (NO OPTIONAL START ADDRESS BY DEFAULT) AND PUTS THE EXECUTING ADDRESS
0426                             ;OP THE LOAD/TESTS ROUTINE IN THE PERIMETER "GO" JUMP ADDRESS BUFFER.
0426                             ;THE SAVE SET-UP SETS THE NUMBER OF WINDOWS TO 4 AND STORES THE EXECUTING ADDRESS OF THE
0426                             ;SAVE PREAMBLE ROUTINE IN THE PERIMETER "GO" JUMP ADDRESS BUFFER (0888).
0426                             ;THE 4 TAPE SAVE WINDOWS ARE: THE FILE NUMBER, THE START, THE END AND THE OPTIONAL AUTO
0426                             ;GO ADDRESS.
0426                             ;ALL THE ABOVE ROUTINES HAVE A COMMON SET-UP AREA. THIS COMMON AREA STORES THE ROUTINE'S
0426                             ;JUMP ADDRESS, IN HL, AND THE NUMBER OF WINDOWS, IN A, BOTH PROVIDED FROM THEIR OWN
0426                             ;DEDICATED SECTION. THE COMMON AREA ALSO CLEARS THE "ACTIVE WINDOW NUMBER" TO ZERO SO THAT
0426                             ;THE PERIMETER HANDLER WILL BE ENTERED WITH THE FIRST WINDOW (FILE NUMBER) SHOWING.
0426                             ; 
0426                             ;"LOAD" SET-UP
0426                J_TAPE_LOAD:      
0426   AF                     XOR   A   ;CLEAR A FOR LOAD SIGN-ON BYTE
0427                             ; 
0427                             ;COMMON AREA FOR LOAD AND TESTS
0427   32 8A 08     L0427:    LD   (TAPE_ACTN),A   ;SAVE SIGN-ON BYTE IN BUFFER
042A   3E 01                  LD   A,0x01   ;LOAD A WITH NUMBER OF WANTED
042C   21 FF FF               LD   HL,0xFFFF   ;WINDOWS -1 (2 WINDOWS): SET
042F   22 9A 08               LD   (TAPE_START),HL   ;OPTIONAL START WINDOW TO FFFF
0432   21 31 05               LD   HL,TAPE_INPUT   ;LOAD HL WITH "GO" ADDR OF LOAD/TEST
0435   18 0D                  JR   L0444   ;ROUTINE: JUMP TO STORE HL AND A
0437                             ; 
0437                             ;"TEST BLOCK" SET-UP
0437                J_TAPE_TEST:      
0437   3E 02                  LD   A,0x02   ;2=TEST BLOCK SIGN-ON BYTE
0439   18 EC        L0439:    JR   L0427   ;JUMP TO TEST/LOAD COMMON AREA
043B                             ; 
043B                             ;"TEST CHECKSUM" SET-UP
043B                J_TAPE_CHKS:      
043B   3E 03                  LD   A,0x03   ;3=TEST CHECKSUM SIGN-ON BYTE
043D   18 FA                  JR   L0439   ;JUMP TO TEST/LOAD COMMON AREA
043F                             ; 
043F                             ;SAVE SET-UP
043F                J_TAPE_SAVE:      
043F   21 50 04               LD   HL,TAPE_SAVE_SETUP   ;POINT HL TO START OF SAVE PRE-AMBLE
0442   3E 03                  LD   A,0x03   ;SET UP FOR 4 WINDOWS
0444                             ; 
0444                             ;COMMON AREA FOR ALL SET-UPS
0444   22 88 08     L0444:    LD   (PERI_J_ADR),HL   ;STORE HL WITH GO CALL ROUTINE
0447   32 87 08               LD   (PERI_W_MAX),A   ;STORE A WITH TOTAL PERIMITER WINDOWS
044A   AF                     XOR   A   ;SET MEN TO FIRST WINDOW (FILE NUMBER)
044B   32 86 08               LD   (PERI_W_CUR),A   ; 
044E   18 23                  JR   L0473   ;JUMP TO PERIMETER HANDLER
0450                             ; 
0450                             ;SAVE ROUTINE PRE-AMBLE
0450                             ;THE SAVE PREAMBLE FITS IN BETWEEN THE PERIMETER HANDLER AND THE ACTUAL SAVE ROUTINE. THE
0450                             ;PURPOSE OF IT IS TO SHIFT ACROSS THE FILE NUMBER, THE START ADDRESS AND THE OPTIONAL GO
0450                             ;ADDRESS. IT ALSO CALCULATES THE LENGTH OF THE BLOCK AND TRANSFERS IT ACROSS TO THE TAPE
0450                             ;FILE INFORMATION BLOCK WHICH IS OUTPUTTED TO THE TAPE.
0450                             ;IF THE END IS LOWER THAN THE START THE ROUTINE WILL JUMP TO DISPLAY "Err -In".
0450                TAPE_SAVE_SETUP:      
0450   2A 9E 08               LD   HL,(TAPE_AUTOG)   ;SHIFT OPTIONAL GO TO OUTPUT BUFFER
0453   22 AA 08               LD   (TAPE_O_GO),HL   
0456   2A 9A 08               LD   HL,(TAPE_START)   ;SHIFT START ADDRESS OF BLOCK
0459   22 A6 08               LD   (TAPE_O_STA),HL   ;TO TAPE FILE OUTPUT BUFFER
045C   EB                     EX   DE,HL   ;PUT START OF BLOCK IN DE
045D   2A 9C 08               LD   HL,(TAPE_END)   ;GET END OF BLOCK IN HL
0460   B7                     OR   A   ;CLEAR CARRY
0461   ED 52                  SBC   HL,DE   ;CALCULATE NUMBER OF BYTES IN
0463   23                     INC   HL   ;BLOCK (DIFFERENCE +1)
0464   DA 4A 00               JP   C,L004A   ;JUMP IF CARRY TO "Err-In"
0467   22 A8 08               LD   (TAPE_O_LEN),HL   ;STORE COUNT IN FILE INFO OUTPUT
046A   2A 98 08               LD   HL,(TAPE_FILE)   ;SHIFT FILE NUMBER TO
046D   22 A4 08               LD   (TAPE_O_FIL),HL   ;TAPE FILE INFO OUTPUT BUFFER
0470   C3 F0 04               JP   TAPE_SAVE   ;JUMP TO SAVE OUTPUT ROUTINE
0473                             ; 
0473                             ;FINAL TAPE SET-UP BEFORE THE PERIMETER HANDLER. THIS PLACES FFFF IN THE OPTIONAL GO WINDOW
0473                             ;BEFORE ENTERING THE PERIMETER HANDLER.
0473                             ; 
0473   21 FF FF     L0473:    LD   HL,0xFFFF   ;PUT FFFF IN OPTIONAL GO WINDOW
0476   22 9E 08               LD   (TAPE_AUTOG),HL   ; 
0479                             ; 
0479                             ;PERIMETER HANDLER
0479                             ;THE PERIMETER HANDLER ROUTINE IS SIMILAR TO THE MENU DRIVER. THE MAJOR DIFFERENCES ARELISTED BELOW:
0479                             ;THE PERIMETER HANDLER CREATES ITS OWN ADDRESS DISPLAY CODES BY CONVERTING THE CONTENTS
0479                             ;OF THE ACTIVE WINDOW TO DISPLAY CODE AND THEREFORE DOES NOT REQUIRE A TABLE OF ADDRESS DISPLAY CODES.
0479                             ;ANOTHER DIFFERENCE IS THE ADDRESS OF THE ROUTINE TO BE EXECUTED ON A "GO" PRESS IS SUPPLIED
0479                             ;BY THE CALLING ROUTINE. THEREFORE THE PERIMETER HANDLER DOESN'T REQUIRE A JUMP TABLE AND
0479                             ;ASSOCIATED CALCULATER.
0479                             ;THE ONLY OTHER MAJOR DIFFERENCE IS THAT THE PERIMETER HANDLER HAS ITS OWN BUILT IN DATA
0479                             ;KEY HANDLER WHILE THE MENU DOES NOT.
0479                             ;THE FRONT SECTION BELOW CALCULATES THE ADDRESS OF THE ACTIVE WINDOW AND THE ADDRESS OF
0479                             ;THE DATA DISPLAY FROM THE DISPLAY TABLE.
0479                             ;THE MENU ENTRY NUMBER FROM THE MENU DRIVER HAS AN EQUIVALENT HERE. IT IS THE ACTIVE WINDOW
0479                             ;NUMBER AND IS USEDIN IDENTICAL FASHION.
0479                             ; 
0479                          .ORG   $0479   
0479   3A 86 08     PERI_RTN:   LD   A,(PERI_W_CUR)   ;GET NUMBER OF ACTIVE WINDOW
047C   2A 84 08               LD   HL,(PERI_W_ADD)   ;GET ADDRESS OF FIRST (FILE) WINDOW+1
047F   ED 5B 82 08            LD   DE,(PERI_D_TBL)   ;GET BASE OF DATA DISPLAY TABLE
0483   B7                     OR   A   ;TEST ACTIVE WINDOW NUMBER FOR ZERO
0484   28 07                  JR   Z,L048D   ;SKIP CALCULATOR IF ZERO
0486   13           L0486:    INC   DE   ;FINE CURRENT DATA DISPLAY
0487   13                     INC   DE   ;AND WINDOW
0488   23                     INC   HL   
0489   23                     INC   HL   
048A   3D                     DEC   A   
048B   20 F9                  JR   NZ,L0486   
048D                             ; 
048D                             ;AFTER THE ADDRESS+1 OF THE ACTIVE WINDOW IS CALCULATED, IT IS STORED IN A BUFFER (AT
048D                             ;088C). EACH TIME A DATA KEY 1S PRESSED, HL IS LOADED FROM THIS BUFFER AND THEREFORE POINTS
048D                             ;TO THE ACTIVE WINDOW. THE DATA CAN THEN BE SHIFTED INTO THE ACTIVE WINDOW IMMEDIATELY.
048D                             ; 
048D   22 8C 08     L048D:    LD   (PERI_W_AC1),HL   ;STORE ACTIVE WINDOW ADDRESS+l
0490                             ; 
0490                             ;BELOW THE DATA DISPLAY BYTES ARE PUT INTO THE DATA SECTION OF THE DISPLAY BUFFER VIA HL.
0490   EB                     EX   DE,HL   ;PUT DATA DISPLAY ADDRESS IN HL
0491   7E                     LD   A,(HL)   ;GET RIGHT-HAND DISPLAY BYTE IN A
0492   23                     INC   HL   ;AND LEFT-HAND IN H
0493   66                     LD   H,(HL)   ;PUT RIGHT-HAND BYTE IN L
0494   6F                     LD   L,A   ;HL HOLDS THE DATA DISPLAY BYTES
0495   22 04 08               LD   (DISP_DBUFF),HL   ;STORE DATA DISPLAY IN BUFFER
0498                             ; 
0498                             ;BELOW THE 16 BIT CONTENTS OF THE ACTIVE WINDOW ARE CONVERTED TO DISPLAY CODE ARE PLACED
0498                             ;IN THE ADDRESS SECTION OF THE DISPLAY BUFFER.
0498                             ; 
0498   EB                     EX   DE,HL   ;GET ACTIVE WINDOW ADDRESS FROM DE
0499   7E                     LD   A,(HL)   ;AND TRANSFER
049A   2B                     DEC   HL   ;THE 16 BIT CONTENTS OF THE ACTIVE
049B   6E                     LD   L,(HL)   ;WINDOW INTO HL
049C   67                     LD   H,A   ;READY TO COVERT TO DISPLAY CODE
049D   01 00 08               LD   BC,DISP_BUFF   ;BC=DISPLAY BUFFER START
04A0   CD 30 08               CALL   HL_2_DIS   ;CALL CONVERSION HL TO DISPLAY CODE
04A3                             ; 
04A3                             ;THE DISPLAY BUFFER IS NOW SET-UP AND THE SCAN/KEY LOOP IS CALLED. WHEN A KEY IS PRESSED,
04A3                             ;A COMMON KEY HANDLER IS CALLED.
04A3                             ;THE COMMON KEY HANDLER DOES ALL THE REQUIRED PROCESSING FOR THE "+", "- " AND "AD" KEYS.
04A3                             ;IF EITHER THE "GO" OR A DATA KEY IS PRESSED, THEN THE HANDLER RETURNS WITH THE FLAGS SET
04A3                             ;TO SIGNIFY THESE KEYS.
04A3                             ;IF "GO" IS PRESSED THEN THE ZERO FLAG IS SET AND THE "GO" HANDLER BELOW IS EXECUTED. IF
04A3                             ;A DATA KEY IS PRESSED THEN THE ZERO FLAG IS CLEAR (NOT ZERO) AND CARRY FLAG IS CLEAR THE
04A3                             ;DATA KEY HANDLER IS EXECUTED IF THESE CONDITIONS ARE MET.
04A3                             ; 
04A3   CD 42 08     PERI_SFT:   CALL   SCAN_IO   ;CALL SCAN/KEY/LCD/PATCH ROUTINE
04A6   21 86 08               LD   HL,PERI_W_CUR   ;POINT HL TO ACTIVE WINDOW NUMBER
04A9   CD B2 04               CALL   MENU_KEY   ;CALL COMMON KEY HANDLER
04AC   20 16                  JR   NZ,PERI_D_KEY   ;JUMP IF NOT GO KEY TO TEST FOR DATA
04AE   2A 88 08               LD   HL,(PERI_J_ADR)   ;OR CONTROL KEY: ELSE GET JUMP ADDRESS
04B1   E9                     JP   (HL)   ;STORED BY SET-UP AND GO
04B2                             ; 
04B2                             ;COMMON KEY HANDLER
04B2                             ;BECAUSE THE PERIMETER HANDLER AND THE MENU DRIVER ARE VERY SIMILAR, THEY ARE ABLE TO
04B2                             ;SHARE A COMMON KEY HANDLER.
04B2                             ;THE ACTION OF THE KEY HANDLER IS AS FOLLOWS:
04B2                             ;IF THE "AD" KEY IS PRESSED, THEN THE RETURN ADDRESS IS POPPED OFF THE STACK AND A RETURN
04B2                             ;IS DONE TO THE CALLING ROUTINE (USUALLY JMON). IF THE "GO" KEY IS PRESSED, THEN THE ZERO
04B2                             ;FLAG WILL BE SET AND A RETURN DONE. IT IS THEN UP TO THE CALLING ROUTINE TO SERVICE THE
04B2                             ;"GO" KEY.
04B2                             ;A DATA KEY WILL BE FLAGGED BY SETTING THE CARRY FLAG AND CLEARING THE ZERO FLAG. LIKE
04B2                             ;THE "GO" KEY, THE CALLING ROUTINE MUST DECIDE WHAT IT IS TO DO WITH THE DATA KEY (THERE
04B2                             ;IS A BUILT IN DATA KEY HANDLER FOR THE PERIMETER HANDLER).
04B2                             ;IF EITHER THE "+" OR "-" KEYS ARE PRESSED THEN A SPECIAL ROUTINE IS CALLED. THIS ROUTINE
04B2                             ;WILL ALTER THE CURRENT NUMBER OF THE ACTIVE WINDOW OR MENU ENTRY. THE RESULT IS THAT WHEN
04B2                             ;THE DISPLAY IS UP-DATED, THE DISPLAYS WILL BE SHIFTED TO EITHER THE NEXT DISPLAY FOR "+"
04B2                             ;OR TO THE PREVIOUS ONE FOR "- " AND WRAP-AROUND IF REQUIRED.
04B2                             ; 
04B2   FE 10        MENU_KEY:   CP   K_PLUS   ;IS THE KEY
04B4   28 1B                  JR   Z,MENU_K_HDL   ;JUMP IF SO TO "+" HANDLER
04B6   FE 11                  CP   K_MINUS   ;IS IT "-"
04B8   28 17                  JR   Z,MENU_K_HDL   ;JUMP IF SO TO "-" HANDLER
04BA   FE 13                  CP   K_ADDR   ;IS IT "AD"
04BC   20 02                  JR   NZ,L04C0   ;JUMP IF NOT TO TEST FOR "GO"
04BE   E1                     POP   HL   ;CLEAN UP STACK
04BF   C9                     RET      ;RETURN TO JMON (OR CALLING ROUTINE)
04C0   FE 12        L04C0:    CP   K_GO   ;IS IT "GO"
04C2   3F                     CCF      ;CLEAR CARRY IF NOT IF GO C=1 Z=1
04C3   C9                     RET      ;IF DATA SET Z=0 C=0: RETURN
04C4                             ; 
04C4                             ;BELOW IS THE PERIMETER HANDLER DATA KEY HANDLER/DISCRIMINATOR
04C4                             ;IF THE KEY WAS "+" OR "-" THEN IT HAS ALREADY BEEN HANDLED AND THIS CONDITION IS FLAGGED
04C4                             ;BY THE CARRY BEING SET. IN THIS CASE, A JUMP IS DONE BACK TO THE MAIN BODY TO UP-DATE
04C4                             ;THE DISPLAY OTHERWISE THE DATA KEY VALUE IS SHIFTED INTO THE ACTIVE WINDOW.
04C4                             ; 
04C4   38 B3        PERI_D_KEY:   JR   C,PERI_RTN   ;JUMP IF KEY WAS "+" OR "-”
04C6   2A 8C 08               LD   HL,(PERI_W_AC1)   ;POINT HL TO ACTIVE WINDOW+1
04C9   2B                     DEC   HL   ;POINT TO LOW ORDER BYTE
04CA   ED 6F                  RLD      ;SHIFT IN DATA KEY VALUE
04CC   23                     INC   HL   ;AND SHIFT OTHER NIBBLES
04CD   ED 6F                  RLD      ;ACROSS
04CF   18 A8                  JR   PERI_RTN   ;JUMP BACK TO UP-DATE DISPLAY
04D1                             ; 
04D1                             ;THIS ROUTINE IS CALLED FROM THE COMMON KEY HANDLER IF EITHER "+" OR "-" HAVE BEEN PUSHED.
04D1                             ;THIS ROUTINE WILL EITHER INCREMENT OR DECREMENT THE MEMORY LOCATION ADDRESSED BY HL FOR
04D1                             ;THE "+" AND "-" KEY RESPECTIVELY. HL WAS LOADED BY THE CALLING ROUTINE TO POINT TO ITS
04D1                             ;MAIN CONTROLLING BYTE. THIS IS EITHER THE CURRENT MENU ENTRY NUMBER (MENU DRIVER), OR
04D1                             ;THE ACTIVE WINDOW NUMBER (PERIMETER HANDLER) , BOTH OF WHICH HAVE BEEN DESCRIBED PREVIOUSLY.
04D1                             ;AFTER INCREMENTING OR DECREMENTING (HL), THIS ROUTINE THEN CHECKS THAT THE VALUE IN (HL)
04D1                             ;IS NOT GREATER THAT THE BYTE AT HL+1 (WHICH IS THE MAXIMUM NUMBER OF DISPLAYS LESS 1).
04D1                             ;KEEP IN MIND, IF IT UNDERFLOWED FROM ZERO IT WILL BECOME FF AND BE HIGHER THAN (HL). THIS
04D1                             ;SECOND BYTE (AT HL+1) IS THE NUMBER OF ALLOWABLE DISPLAYS-1 AND WAS PROVIDED BY THE ROM
04D1                             ;TABLE FOR THE (TAPE) MENU DRIVER, AND PROVIDED BY THE PERIMETER HANDLER SET-UP ROUTINES
04D1                             ;(REFER TO 042A AND 0442).
04D1                             ;IF THE FIRST BYTE BECOMES HIGHER THAN THE SECOND., THEN THE ROUTINE CHECKS TO SEE WHICH
04D1                             ;KEY WAS PRESSED. IF THE "+" KEY WAS, THEN (HL) IS CLEARED. THIS WILL CAUSE MENU OR
04D1                             ;PERIMETER HANDLER TO SHOW ITS FIRST DISPLAY WHEN RE-ENTERED.
04D1                             ;IF THE KEY WAS "-", THEN THE MAXIMUM NUMBER OF DISPLAYS-1 (WHICH IS THE SAME AS THE NUMBER
04D1                             ;OF THE FINAL DISPLAY) IS TRANSFERRED INTO (HL) (THE NUMBER OF THE CURRENT DISPLAY). THIS
04D1                             ;WILL CAUSE THE LAST DISPLAY TO BE SHOWN WHEN THE MENU DRIVER OR PERIMETER HANDLER IS
04D1                             ;RE-ENTERED.
04D1                             ;IF THERE IS NO UNDERFLOW OR OVERFLOW THEN THE ROUTINE RETURNS JUST AFTER IT HAS EITHER
04D1                             ;INCREMENTED OR DECREMENTED THE CURRENT NUMBER OF THE MENU ENTRY NUMBER OR ACTIVE WINDOW
04D1                             ;NUMBER.
04D1                             ;WHEN THE MENU DRIVER OR PERIMETER HANDLER ARE RE-ENTERED, THEY WILL SHOW THE NEXT DISPLAY
04D1                             ;FOR "+" OR THE PREVIOUS FOR "-" AND WRAP-AROUND AUTOMATICALLY IF REQUIRED.
04D1                             ; 
04D1                          .ORG   $04D1   
04D1   4F           MENU_K_HDL:   LD   C,A   ;SAVE INPUT KEY VALUE IN C
04D2   23                     INC   HL   ;PUT MAX NUMBER OF DISPLAYS-1
04D3   46                     LD   B,(HL)   ;IN B
04D4   2B                     DEC   HL   ;RESET HL TO POINT TO CURRENT NUMBER
04D5   0F                     RRCA      ;WAS KEY "+" OR "-"? BIT 0 WILL TELL
04D6   7E                     LD   A,(HL)   ;PUT CURRENT NUMBER IN A
04D7   38 02                  JR   C,L04DB   ;JUMP IF KEY WAS "-"
04D9   3C                     INC   A   ;INCREASE A BY 2
04DA   3C                     INC   A   ; 
04DB   3D           L04DB:    DEC   A   ;DECREASE A BY ONE
04DC   04                     INC   B   ;ADD 1 TO MAX NUMBER-1: IS CURRENT
04DD   B8                     CP   B   ;NUMBER EQUAL OR GREATER THAN MAX?
04DE   30 05                  JR   NC,L04E5   ;JUMP IF SO TO UNDER/OVERFLOW HANDLER
04E0   77           L04E0:    LD   (HL),A   ;ELSE STORE UPDATED CURRENT NUMBER
04E1   AF                     XOR   A   ;SET ZERO FLAG
04E2   3D                     DEC   A   ;CHANGE ZERO FLAG TO 0
04E3   37                     SCF      ;AND SET CARRY
04E4   C9                     RET      ;DONE
04E5   CB 41        L04E5:    BIT   0,C   ;TEST FOR "+" OR "-"
04E7   20 03                  JR   NZ,L04EC   ;JUMP IF "-" TO SET CURRENT NUMBER
04E9   AF                     XOR   A   ;TO LAST DISPLAY: ELSE SET FIRST
04EA   18 F4                  JR   L04E0   ;DISPLAY: JUMP TO STORE NEW NUMBER
04EC   05           L04EC:    DEC   B   ;CORRECT MAX NUMBER-1
04ED   78                     LD   A,B   ;SET A TO LAST DISPLAY NUMBER
04EE   18 F0                  JR   L04E0   ;JUMP TO STORE LAST DISPLAY NUMBER
04F0                             ; 
04F0                             ;THIS IS THE TAPE OUTPUT ROUTINE
04F0                             ;THE ACTION IS AS FOLLOWS:
04F0                             ;A LEADER OF LOW FREQUENCY TONE IS OUTPUTTED FOLLOWED BY THE FILE INFORMATION BLOCK.
04F0                             ;AFTER THE FILE INFORMATION BLOCK IS OUTPUTTED, SEVERAL SECONDS OF HIGH FREQUENCY MIDDLE
04F0                             ;SYNC IS OUTPUTTED, THE TIME IT TAKES TO OUTPUT THE MIDDLE SYNC IS USED BY THE TAPE INPUT
04F0                             ;ROUTINE TO DISPLAY THE FILE NUMBER.
04F0                             ;THE DATA TO BE SAVED ON TAPE IS BROKEN UP INTO BLOCKS OF 256 BYTES AND OUTPUTTED WITH A
04F0                             ;CHECKSUM AT THE END OF EACH BLOCK. A COUNTER IS SHOWN ON THE TEC LED DISPLAY THAT SHOWS
04F0                             ;HOW MANY COMPLETE BLOCKS LEFT (UP TO 16 BLOCKS).
04F0                             ;IF THERE IS AN ODD SIZE BLOCK, IT IS OUTPUTTED AS THE LAST BLOCK.
04F0                             ;AFTER ALL THE BLOCKS HAVE BEEN OUTPUTTED, AN END OF FILE HIGH FREQUENCY TONE IS OUTPUTTED.
04F0                             ; 
04F0   21 00 30     TAPE_SAVE:   LD   HL,0x3000   ;HL HAS NUMBER OF LEADER CYCLES
04F3   CD 80 06               CALL   LOW_TONE   ;CALL LOW TONE
04F6   21 A4 08               LD   HL,TAPE_O_FIL   ;HL IS START OF FILE INFORMATION BLOCK
04F9   06 0C                  LD   B,0x0C   ;LOAD B WITH NUMBER OF BYTES TO BE
04FB   AF                     XOR   A   ;OUTPUTTED: ZERO A FOR CHECKSUM
04FC   CD 4B 06               CALL   TAPE_OUT   ;CALL OUT BLOCK
04FF   21 00 50               LD   HL,0x5000   ;LD HL WITH MID SYNC CYCLE COUNT
0502   CD 84 06               CALL   HIGH_TONE   ;CALL HIGH TONE
0505   2A A6 08               LD   HL,(TAPE_O_STA)   ;LOAD HL, WITH START OF OUTPUT BLOCK
0508                             ; 
0508                             ;OUTPUT LOOP STARTS HERE
0508                             ;THE DISCUSSION BELOW ON THE BYTE COUNTER AND BLOCK FORMATION APPLIES TO THE TAPE INPUT
0508                             ;LOOP ALSO. THE TAPE INPUT LOOP DESCRIPTION WILL REFER YOU BACK TO THESE NOTES.
0508                             ;THE BYTE COUNT IS PUT INTO BC AND THEN A ROUTINE TO CONVERT B (THE TOTAL NUMBER OF FULL
0508                             ;BLOCKS TO BE OUTPUTTED) TO DISPLAY FORMAT AND OUTPUT IT IS CALLED.
0508                             ;THE CONVERSION ROUTINE ALSO TESTS B FOR ZERO. IF B IS NOT ZERO, THE ROUTINE RETURNS WITH
0508                             ;THE ZERO FLAG CLEAR (NOT ZERO) AND THE HIGH ORDER BYTE OF THE BYTE COUNT IN B IS DECREMENTED
0508                             ;BY ONE AND STORED IN ITS BUFFER. THIS COUNTS DOWN THE BLOCKS. B IS THEN ZEROED SO THAT
0508                             ;A FULL BLOCK (256 BYTES) WILL BE OUTPUTTED ON RETURNING.
0508                             ;IF THE HIGH ORDER BYTE OF THE BYTE COUNT (IN B) IS ZERO (NO FULL BLOCK OF 256 BYTES) THEN
0508                             ;C (THE LOW ORDER BYTE OF THE COUNT) IS TRANSFERRED INTO B AND THE ZERO FLAG IS SET.
0508                             ;THE CONVERSION THEN RETURNS WITH THE NUMBER (IF ANY) OF REMAINING BYTES IN B.
0508                             ;AFTER THE CONVERSION ROUTINE HAS RETURNED, A JUMP IS DONE IF THE ZERO FLAG IS CLEAR
0508                             ;(DENOTING A NOT ZERO STATE). THIS JUMP SKIPS AHEAD TO SAVE THE FLAGS AND OUTPUT ONE FULL
0508                             ;BLOCK
0508                             ;IF THE ZERO FLAG IS SET, THEN THE ROUTINE BELOW CHECKS TO SEE IF THE LOW ORDER BYTE (FROM
0508                             ;C) THAT HAS BEEN PLACED IN B, IS ZERO. IF THE LOW ORDER BYTE IS ZERO, THEN ALL THE BYTES
0508                             ;HAVE BEEN OUTPUTTED. THE ROUTINE THEN JUMPS TO DISPLAY " -END -S".
0508                             ;IF THE LOW ORDER BYTE OF THE COUNT IS NOT ZERO THEN THE ZERO FLAG IS SET AND SAVED ON
0508                             ;THE STACK BEFORE WHAT ARE NOW KNOWN TO BE THE LAST IS OUTPUTTED.
0508                             ;BEFORE THE DATA IS SENT TO THE TAPE, A SHORT HIGH TONE SYNC IS OUTPUTTED TO COVER THE
0508                             ;SOFTWARE OVERHEAD OF THE TAPE INPUT ROUTINE, AND A IS ZEROED TO BE USED AS THE CHECK-SUM.
0508                             ; 
0508   ED 4B A8 08  START_BLK:   LD   BC,(TAPE_O_LEN)   ;LOAD BC WITH NUMBER OF BYTES
050C   CD C9 05               CALL   TAPE_DISP   ;CALL ROUTINE TO DISPLAY BLOCK COUNT
050F   20 05                  JR   NZ,L0516   ;AND TEST LENGTH: JUMP IF FULL BLOCK
0511   78                     LD   A,B   ;TO OUTPUT: TEST LOW BYTE OF COUNT
0512   B7                     OR   A   ;IN B IS ZERO AND JUMP TO DISPLAY
0513   28 11                  JR   Z,END_BLOCK   ;"-END-S" IF SO
0515                             ; 
0515                             ;THE XOR A INSTRUCTION BELOW SETS THE ZERO FLAG TO SIGNIFY THAT THE BLOCK ABOUT TO BE
0515                             ;OUTPUTTED IS THE FINAL BLOCK. THE ROUTINE WILL THEN DISPLAY "-END-S" (AFTER A SHORT END
0515                             ;SYNC TONE).
0515                             ; 
0515   AF                     XOR   A   ;SET ZERO FLAG
0516   F5           L0516:    PUSH   AF   ;AND SAVE ON STACK
0517                             ; 
0517                             ;AT THIS POINT IF THE ZERO FLAG ON THE STACK IS CLEAR (NOT ZERO STATE), THEN AFTER THE
0517                             ;CURRENT BLOCK IS OUTPUTTED, THE ROUTINE WILL LOOP BACK TO START OF THE OUTPUT LOOP TO
0517                             ;SEE IF THERE IS ANY MORE BYTES TO BE OUTPUTTED.
0517   D9                     EXX      ;SWAP REGISTERS
0518   21 14 02               LD   HL,0x0214   ;LOAD HL FOR SHORT BURST OF
051B   CD 84 06               CALL   HIGH_TONE   ;HIGH TONE
051E   D9                     EXX      ;SWAP BACK REGISTERS
051F   AF                     XOR   A   ;ZERO A FOR CHECKSUM
0520   CD 4B 06               CALL   TAPE_OUT   ;CALL OUTBLOCK
0523   F1                     POP   AF   ;RECOVER FLAGS AND JUMP IF
0524   20 E2                  JR   NZ,START_BLK   ;THERE MIGHT BE MORE TO OUTPUT
0526                             ; 
0526                             ;ALL BLOCKS HAVE BEEN OUTPUTTED SO FINISH WITH A SHORT END TONE AND SET-UP END DISPLAY "-END-S".
0526   21 00 10     END_BLOCK:   LD   HL,0x1000   ;LOAD HL WITH SHORT END TONE
0529   CD 84 06               CALL   HIGH_TONE   ;CALL HIGH TONE
052C   3E 05                  LD   A,0x05   ;LD A TO INDEX "END-S DISPLAY
052E   C3 E6 03               JP   MENU_RTNT   ;JUMP BACK TO MENU
0531                             ; 
0531                             ;THIS IS THE START OF THE TAPE INPUT SECTION.
0531                             ;THE ACTION HERE IS TO DETECT A VALID LEADER BY COUNTING 1000H CYCLES OF LOW FREQUENCY
0531                             ;TONE. AFTER THIS HAS BEEN DETECTED, THE ROUTINE WAITS UNTIL IT DETECTS THE START BIT OF
0531                             ;THE FILE INFORMATION BLOCK. THE BLOCK IS THEN LOADED IN AND A CHECK-SUM COMPARE IS DONE.
0531                             ;IF AN ERROR IS DETECTED, THE ROUTINE JUMPS TO DISPLAY "FAIL -XX", OTHERWISE THE FILE
0531                             ;NUMBER IS CONVERTED TO DISPLAY FORMAT AND DISPLAYED FOR A FEW SECONDS.
0531                             ; 
0531   01 00 10     TAPE_INPUT:   LD   BC,0x1000   ;LOAD BC TO COUNT 0x1000 CYCLES
0534   CD 30 06     L0534:    CALL   READ_TAPE   ;CALL PERIOD
0537   38 F8                  JR   C,TAPE_INPUT   ;LOOP UNTIL LOW TONE IS DETECTED
0539   0B                     DEC   BC   ;COUNT LONG
053A   78                     LD   A,B   ;PERIODS
053B   B1                     OR   C   ;IF BC REACHES ZERO THEN IT IS
053C   20 F6                  JR   NZ,L0534   ;ACCEPTED THAT A VALID FILE FOLLOWS
053E   06 0C                  LD   B,0x0C   ;LOAD B TO INPUT 12 BYTES AND
0540   21 A4 08               LD   HL,TAPE_O_FIL   ;POINT HL TO FILE INFO BLOCK INPUT
0543   CD 30 06     L0543:    CALL   READ_TAPE   ;BUFFER: CALL PERIOD
0546   30 FB                  JR   NC,L0543   ;AND WAIT FOR LOW TONE TO END
0548   CD E7 05               CALL   LOAD_BLK2   ;CALL INBLOCK TO GET FILE INFO BLOCK
054B   20 54                  JR   NZ,TAPEFAIL   ;JUMP NOT ZERO TO FAIL LOAD ROUTINE
054D   01 00 08               LD   BC,DISP_BUFF   ;LOAD BC TO POINT TO DISPLAY BUFFER
0550   2A A4 08               LD   HL,(TAPE_O_FIL)   ;PUT FILE NUMBER INTO EL
0553   CD 30 08               CALL   HL_2_DIS   ;CONVERT HL TO DISPLAY CODE
0556   3E 47                  LD   A,0x47   ;PUT "F" IN DISPLAY BUFFER
0558   32 05 08               LD   (DISP_D2BUF),A   ;FOR "FILE"
055B   01 F2 01               LD   BC,0x01F2   ;LD BC WITH THE DISPLAY ON TIME
055E   C5           L055E:    PUSH   BC   ;SAVE ON STACK
055F   CD 36 08               CALL   LED_SCAN   ;CALL SCAN
0562   C1                     POP   BC   ;RECOVER BC
0563   0B                     DEC   BC   ;DECREMENT
0564   78                     LD   A,B   ;AND LOOP UNTIL
0565   B1                     OR   C   ;BC IS ZERO
0566   20 F6                  JR   NZ,L055E   
0568                             ; 
0568                             ;AFTER A FILE INFORMATION BLOCK IS LOADED AND THE FILE NUMBER DISPLAYED, A TEST IS DONE
0568                             ;ON THE REQUIRED FILE NUMBER WINDOW. FIRST IT IS TESTED FOR FFFF (LOAD/TEST NEXT FOUND
0568                             ;FILE). IF FFFF, THE ROUTINE SKIPS AHEAD TO LOAD/TEST THE FILE. OTHERWISE THE REQUIRED
0568                             ;FILE NUMBER IS SUBTRACTED FROM THE JUST LOADED FILE NUMBER, IF THE RESULT IS ZERO THEN
0568                             ;THE FILE IS THE ONE SELECTED AND IS LOADED/TESTED.
0568                             ;THE OPTIONAL START WINDOW IS THEN TESTED FOR FFFF. IF IT IS, THE START ADDRESS FROM THE
0568                             ;TAPE IS USED. IF THE OPTIONAL START BUFFER HAS SOMETHING OTHER THAT FFFF, THEN THE ADDRESS
0568                             ;HERE IS USED AS THE START ADDRESS TO LOAD/TEST THE TAPE.
0568                             ; 
0568   2A 98 08               LD   HL,(TAPE_FILE)   ;TEST FOR FFFF IN FILE NAME WINDOW
056B   23                     INC   HL   
056C   7C                     LD   A,H   
056D   B5                     OR   L   
056E   2B                     DEC   HL   ;JUMP IF FILE WINDOW IS FFFF
056F   28 09                  JR   Z,L057A   ;TO INPUT FILE REGARDLESS OF ITS NUMBER
0571   ED 5B A4 08            LD   DE,(TAPE_O_FIL)   ;ELSE TEST THAT INPUT FILE NAME
0575   B7                     OR   A   ;IS THE SAME AS THE ONE IN THE FILE
0576   ED 52                  SBC   HL,DE   ;NUMBER WINDOW AND JUMP IF NOT
0578   20 B7                  JR   NZ,TAPE_INPUT   ;SELECTED FILE TO LOOK FOR NEXT FILE
057A   2A 9A 08     L057A:    LD   HL,(TAPE_START)   ;TEST THAT OPTIONAL START ADDRESS
057D   23                     INC   HL   ;IS FFFF
057E   7C                     LD   A,H   
057F   B5                     OR   L   
0580   2B                     DEC   HL   
0581   20 03                  JR   NZ,L0586   ;JUMP IF NOT, ELSE USE START ADDRESS
0583   2A A6 08               LD   HL,(TAPE_O_STA)   ;PROVIDED FROM THE TAPE
0586                             ; 
0586                             ;THE MAIN LOAD/TEST ROUTINE STARTS HERE.
0586                             ;REFER TO THE DESCRIPTION OF THE BYTE COUNT AND BLOCK FORMATION AT THE OUTPUT SECTION
0586                             ;ROUTINE (SEE 508).
0586                             ;WHEN ALL THE BLOCKS HAVE BEEN INPUTTED AND THE ROUTINE JUMPS TO DISPLAY PASS/FAIL -Ld ON
0586                             ;THE LED DISPLAY.
0586                             ;HL IS POINTING TO THE PLACE IN MEMORY WHERE THE FILE WILL BE LOADED/TESTED.
0586                             ; 
0586   ED 4B A8 08  L0586:    LD   BC,(TAPE_O_LEN)   ;PUT NUMBER OF BYTES INTO BC
058A   CD C9 05               CALL   TAPE_DISP   ;CALL B CONVERT AND TEST
058D   20 05                  JR   NZ,L0594   ;JUMP IF NOT ZERO AS THERE IS AT
058F   78                     LD   A,B   ;LEAST ONE FULL BLOCK TO LOAD/TEST
0590   B7                     OR   A   ;CHECK THAT B (FORMALLY C)=0
0591   28 0A                  JR   Z,L059D   ;JUMP IF SO AS ALL BYTES DONE
0593   AF                     XOR   A   ;ELSE SET ZERO FLAG TO REMEMBER
0594   F5           L0594:    PUSH   AF   ;SAVE FLAGS ON STACK
0595   CD E3 05               CALL   LOAD_BLK   ;CALL INBLOCK
0598   20 06                  JR   NZ,L05A0   ;JUMP IF LOAD/TEST FAILED
059A   F1                     POP   AF   ;RECOVER FLAGS
059B   20 E9                  JR   NZ,L0586   ;LOOP IF THERE MIGHT BE MORE
059D   AF           L059D:    XOR   A   ;SET ZERO (SUCCESS) FLAG
059E   18 01                  JR   TAPEFAIL   ;JUMP TO END HANDLER
05A0   D1           L05A0:    POP   DE   ;CLEAN UP STACK
05A1   20 10        TAPEFAIL:   JR   NZ,PF_ENTRY   ;JUMP IF FAILED LOAD/TEST
05A3                             ; 
05A3                             ;THE LOAD/TEST HAS PASSED. TEST HERE FOR OPTIONAL AUTO-GO AND FOR LOAD OPERATION (NO
05A3                             ;AUTO-GO FOR TEST OPERATIONS). START EXECUTION AT AUTO-GO ADDRESS IF REQUIRED.
05A3                             ; 
05A3   2A AA 08               LD   HL,(TAPE_O_GO)   ;PUT OPTIONAL GO ADDRESS IN HL
05A6   23                     INC   HL   ;TEST FOR FFFF
05A7   7C                     LD   A,H   ;AND JUMP
05A8   B5                     OR   L   ;IF FFFF
05A9   2B                     DEC   HL   ;AS THERE
05AA   28 07                  JR   Z,PF_ENTRY   ;IS NO AUTO-GO
05AC   3A 8A 08               LD   A,(TAPE_ACTN)   ;TEST THAT A LOAD OPERATION WAS
05AF   B7                     OR   A   ;DONE
05B0   20 01                  JR   NZ,PF_ENTRY   ;SKIP JUMP IF IT WAS A TEST
05B2   E9                     JP   (HL)   ;ELSE AUTO START THE PROGRAM
05B3                             ; 
05B3                             ;THE POST LOAD/TEST MENU DISPLAYS ARE SET UP HERE. IF THE LOAD/TEST FAILED THE ZERO FLAG
05B3                             ;IS CLEAR THE ROUTINE WILL POINT TO THE "FAIL" DISPLAY. OTHERWISE IT IS SET TO POINT TO
05B3                             ;THE "PASS" DISPLAY. THE DATA DISPLAY IS CALCULATED BY ADDING THE MENU ENTRY NUMBER OF
05B3                             ;THE JUST PERFORMED OPERATION X2, TO THE TABLE BASE OF POST LOAD/TEST DATA DISPLAYS.
05B3                             ;(THE MENU ENTRY NUMBER IS STILL THE SAME AS IT WAS WHEN "GO" WAS PRESS FROM THE MENU).
05B3                             ; 
05B3                          .ORG   $05B3   
05B3   11 68 07     PF_ENTRY:   LD   DE,TAPE_FDA_TBL   ;LOAD DE TO BASE OF DATA DISPLAY
05B6   21 5C 07               LD   HL,TAPE_FAIL   ;TABLE AND HL "FAIL" DISPLAY
05B9   20 02                  JR   NZ,L05BE   ;TABLE:
05BB   2E 58                  LD   L,0x58   ;ADJUST HL TO PASS IF ZERO
05BD   00           L05BE:    NOP      ;(FROM FIXED ERROR)
05BE   3A 8F 08               LD   A,(MENU_NO)   ;FIND WHAT OPERATION WAS PERFORMED
05C1   07                     RLCA      ;AND DOUBLE VALUE AND ADD TO HL TO
05C2   83                     ADD   A,E   ;POINT DE AT POST TAPE OPERATION
05C3   5F                     LD   E,A   ;DATA DISPLAY ENTRY (SEE 0768-0771)
05C4   00                     NOP      ;(FROM FIXED ERROR)
05C5   AF                     XOR   A   ;ZERO A
05C6   C3 47 00               JP   L0047   ;JUMP TO SOFT MENU ENTRY
05C9                             ; 
05C9                             ;THIS IS THE CONVERT/TEST B ROUTINE.
05C9                             ;THE VALUE IN B IS CONVERTED AND OUTPUTTED TO PORT 2.
05C9                             ;THEN B IS TESTED AND ONE OF THE FOLLOWING OPERATIONS IS PERFORMED. IF B=0 THEN C IS
05C9                             ;TRANSFERRED INTO B AND THE ZERO FLAG IS SET. IF B IS NOT 0 THEN B IS DECREMENTED, THE
05C9                             ;COUNT IS UP-DATED IN ITS BUFFER AND THE ZERO FLAG AND B IS CLEARED.
05C9                             ; 
05C9                          .ORG   $05C9   
05C9   78           TAPE_DISP:   LD   A,B   ;PUT HIGH BYTE OF COUNT IN A
05CA   E6 0F                  AND   0x0F   ;MASK TO ONE DIGIT
05CC   11 D0 07               LD   DE,SEG_TBL   ;POINT DE TO DISPLAY CODE TABLE
05CF   83                     ADD   A,E   ;ADD A
05D0   5F                     LD   E,A   
05D1   1A                     LD   A,(DE)   ;GET DISPLAY VALUE
05D2   D3 02                  OUT   (DSEGMENT),A   ;OUTPUT IT TO DISPLAY
05D4   78                     LD   A,B   ;TEST HIGH BYTE
05D5   B7                     OR   A   ;FOR ZERO
05D6   28 09                  JR   Z,L05E1   ;JUMP IF ZERO
05D8   05                     DEC   B   ;ELSE DECREASE COUNT BY ONE BLOCK
05D9   ED 43 A8 08            LD   (TAPE_O_LEN),BC   ;STORE COUNT
05DD   06 00                  LD   B,0x00   ;LOAD B FOR 256 BYTE OUTPUT BLOCK
05DF   B7                     OR   A   ;CLEAR ZERO FLAG
05E0   C9                     RET      ;DONE
05E1   41           L05E1:    LD   B,C   ;PUT LAST BLOCK SIZE IN B
05E2   C9                     RET      ;DONE
05E3                             ; 
05E3                             ;THIS BLOCK LOADS/TESTS THE BYTES IN FROM THE TAPE. THE NUMBER OF BYTES IS HELD IN B ON
05E3                             ;INPUT. AFTER THE SUB-ROUTINE THAT INPUTS A BYTE IS CALLED, A TEST AND JUMP IS DONE. THE
05E3                             ;TEST AND JUMP SELECT THE REQUIRED CODE TO PERFORM A LOAD OR TEST AS SELECTED FROM THE
05E3                             ;MENU BY THE USER. THE CHECK-SUM LOADED FROM THE TAPE HAS HAD ONE ADDED TO IT BY THE TAPE
05E3                             ;OUTPUT ROUTINE. THIS ADDED ONE IS REMOVED IN THIS ROUTINE BEFORE THE CHECK-SUM COMPARE
05E3                             ;IS DONE.
05E3                             ; 
05E3   3A 8A 08     LOAD_BLK:   LD   A,(TAPE_ACTN)   ;GET CURRENT OPERATION
05E6   4F                     LD   C,A   ;SAVE IN C
05E7   AF           LOAD_BLK2:   XOR   A   ;CLEAR A FOR CHECKSUM
05E8   F5           L05E8:    PUSH   AF   ;SAVE CHECKSUM
05E9   CD 0B 06               CALL   LOAD_BYTE   ;CALL GET BYTE
05EC   CB 49                  BIT   1,C   ;TEST FOR CURRENT OPERATION
05EE   20 0E                  JR   NZ,L05FE   ;JUMP IF A EITHER TEST
05F0   73                     LD   (HL),E   ;ELSE STORE INPUTTED BYTE IN MEMORY
05F1   23                     INC   HL   ;POINT TO NEXT LOCATION
05F2   F1           L05F2:    POP   AF   ;GET CHECKSUM
05F3   83           L05F3:    ADD   A,E   ;ADD TO NEW BYTE
05F4   10 F2                  DJNZ   L05E8   ;DO UNTIL BLOCK DONE
05F6   F5                     PUSH   AF   ;SAVE CHECKSUM
05F7   CD 0B 06               CALL   LOAD_BYTE   ;GET TAPE CHECKSUM
05FA   F1                     POP   AF   ;GET MEMORY CHECKSUM
05FB   1D                     DEC   E   ;CORRECT TAPE CHECKSUM
05FC   BB                     CP   E   ;TEST CHECKSUMS TO SET FLAGS
05FD   C9                     RET      ;BLOCK DONE
05FE   CB 41        L05FE:    BIT   0,C   ;TEST FOR WHICH TEST
0600   20 F0                  JR   NZ,L05F2   ;JUMP IF CHECKSUM ONLY TEST
0602   F1                     POP   AF   ;GET CHECKSUM
0603   57                     LD   D,A   ;SAVE IN D
0604   7B                     LD   A,E   ;GET INPUT BYTE
0605   BE                     CP   (HL)   ;TEST TO MEMORY
0606   23                     INC   HL   ;POINT TO NEXT LOCATION
0607   7A                     LD   A,D   ;PUT CHECKSUM BACK IN A
0608   28 E9                  JR   Z,L05F3   ;JUMP TO MAIN LOOP IF ALL OK
060A   C9                     RET      ;RETURN IF ERROR
060B                             ; 
060B                             ;THIS ROUTINE INPUTS A SINGLE BYTE.
060B   CD 18 06     LOAD_BYTE:   CALL   LOAD_BIT   ;GET START BIT
060E   16 08                  LD   D,0x08   ;LOAD D FOR 8 BITS
0610   CD 18 06     L0610:    CALL   LOAD_BIT   ;GET BIT
0613   CB 1B                  RR   E   ;PUT IT IN E
0615   15                     DEC   D   
0616   20 F8                  JR   NZ,L0610   ;DO FOR EIGHT BITS,
0618                             ; 
0618                             ;THIS ROUTINE INPUTS A SINGLE BIT
0618                             ;THE STRUCTURE OF EACH BIT IS IMPORTANT TO UNDERSTAND AT THIS POINT. A LOGIC 0 IS REPRESENTED
0618                             ;BY 4 SHORT PERIODS FOLLOWED BY 1 LONG PERIOD AND A LOGIC 1 BY 2 SHORT PERIODS AND 2 LONG
0618                             ;PERIODS. THESE ARE HIGH SPEED FIGURES. FOR LOW SPEED THE ABOVE COUNTS ARE DOUBLED.
0618                             ;THE BITS ARE DECODED BY COUNTING THE RATIO OF SHORT PERIODS TO LONG PERIODS. A COMPLICATED
0618                             ;METHOD OF COUNTING IS USED TO RESULT IN THE BIT VALUE BEING REFLECTED IN BIT 7 OF L. THE
0618                             ;ROUTINE IS TERMINATED WHEN A SHORT PERIOD THAT FOLLOWED A LONG PERIOD IS DETECTED. THE
0618                             ;LONG PERIOD IS FLAGGED WITH BIT 0 OF H. THE "SHORT AFTER LONG" PERIOD USED FOR TERMINATION
0618                             ;IS ACTUALLY THE FIRST CELL OF THE NEXT BIT.
0618                             ;THE VALUE OF THE BIT INPUTTED IS THEN POT INTO THE CARRY FLAG.
0618                             ; 
0618   D9           LOAD_BIT:   EXX      ;SWAP REGISTERS
0619   21 00 00               LD   HL,0x0000   ;ZERO HL
061C   CD 30 06     L061C:    CALL   READ_TAPE   ;CALL TO MEASURE PERIOD
061F   38 06                  JR   C,L0627   ;JUMP IF SHORT PERIOD
0621   2D                     DEC   L   ;SET HIGH ORDER BIT OF L TO ONES
0622   2D                     DEC   L   
0623   CB C4                  SET   0,H   ;REMEMBER THAT THE LONG PERIOD
0625   18 F5                  JR   L061C   ;HAS BEEN DETECTED: LOOP BACK
0627   2C           L0627:    INC   L   ;SHORT PERIOD SO ADD ONE TO L
0628   CB 44                  BIT   0,H   ;TEST FOR SHORT AFTER LONG PERIOD
062A   28 F0                  JR   Z,L061C   ;JUMP IF NOT
062C   CB 15                  RL   L   ;END OF BIT: PUT BIT 7,L INTO
062E   D9                     EXX      ;CARRY: SWAP REGISTERS
062F   C9                     RET      ;INPUT BIT IN CARRY
0630                             ; 
0630                             ;THIS ROUTINE INPUTS AND MEASURES THE PERIOD OF EACH TAPE CELL AND COMPARES IT TO THE
0630                             ;THRESHOLD BETWEEN A SHORT AND LONG PERIOD. THE CELL IS ALSO ECHOED ON THE TEC SPEAKER.
0630                             ; 
0630   11 00 00     READ_TAPE:   LD   DE,0x0000   ;ZERO DE FOR PERIOD MEASUREMENT
0633   DB 03        L0633:    IN   A,(P_DAT)   ;TEST TAPE LEVEL
0635   13                     INC   DE   ;TIME PERIOD
0636   17                     RLA      ;PUT TAPE LEVEL INTO CARRY
0637   30 FA                  JR   NC,L0633   ;LOOP UNTIL IT GOES HIGH
0639   AF                     XOR   A   ;ECHO IT ON
063A   D3 01                  OUT   (DSCAN),A   ;THE TEC SPEAKER
063C   DB 03        L063C:    IN   A,(P_DAT)   ;MEASURE SECOND HALF OF CYCLE
063E   13                     INC   DE   ;IN THE SAME FASHION AS ABOVE
063F   17                     RLA      
0640   38 FA                  JR   C,L063C   ;THIS TIME LOOP UNTIL TAPE LEVEL
0642   3E 84                  LD   A,0x84   ;GOES LOW: ECHO IT ON TEC SPEAKER
0644   D3 01                  OUT   (DSCAN),A   
0646   7B                     LD   A,E   ;GET PERIOD MEASUREMENT
0647   FE 1A                  CP   0x1A   ;COMPARE IT TO THRESHOLD
0649   C9                     RET      ;TO SET FLAGS: DONE
064A                             ; 
064A                             ;THIS ROUTINE OUTPUTS A BLOCK TO THE TAPE. THE NUMBER OF BYTES IS HELD IN B AND THE BLOCK
064A                             ;IS ADDRESS BY HL. AFTER ALL THE BYTES HAVE BEEN OUTPUTTED, THE CHECKSUM +1, WHICH WAS
064A                             ;ADDED OF AS EACH BYTE WAS OUTPUTTED, IS SENT TO THE TAPE.
064A                             ; 
064A   08           L064A:    EX   AF,AF'   ;GET CHECKSUM IN A
064B   5E           TAPE_OUT:   LD   E,(HL)   ;PUT BYTE TO BE OUTPUTTED IN E
064C   83                     ADD   A,E   ;ADD FOR CHECKSUM
064D   08                     EX   AF,AF'   ;SAVE IN ALTERNATE AF
064E   CD 57 06               CALL   SAVE_BYTE   ;CALL OUT BYTE
0651   23                     INC   HL   ;POINT TO NEXT BYTE
0652   10 F6                  DJNZ   L064A   
0654   08                     EX   AF,AF'   ;GET CHECKSUM
0655   3C                     INC   A   ;INCREASE IT BY ONE
0656   5F                     LD   E,A   ;PUT IT IN E
0657                             ; 
0657                             ;THIS ROUTINE OUTPUTS A SINGLE BYTE IN E TO THE TAPE. THE FORMAT IS 1 START BIT, EIGHT
0657                             ;DATA BITS AND 1 STOP BIT.
0657                             ; 
0657   16 08        SAVE_BYTE:   LD   D,0x08   ;SET D FOR 8 BITS
0659   B7                     OR   A   ;CLEAR CARRY AND CALL OUTBIT
065A   CD 66 06               CALL   SAVE_BIT   ;TO OUTPUT BINARY ZERO FOR START BIT
065D   CB 1B        L065D:    RR   E   ;PUT FIRST BIT IN CARRY
065F   CD 66 06               CALL   SAVE_BIT   ;CALL OUT BIT
0662   15                     DEC   D   
0663   20 F8                  JR   NZ,L065D   ;DO FOR 8 BITS
0665   37                     SCF      ;SET CARRY TO OUTPUT STOP BIT (1)
0666                             ; 
0666                             ;THIS ROUTINE OUTPUTS A SINGLE BIT. IF THE CARRY IS SET, THEN A LOGIC 1 IS OUTPUTTED
0666                             ;OTHERWISE A LOGIC O.
0666                             ;A 1 IS REPRESENTED BY 2 SHORT AND 2 LONG PERIODS.
0666                             ;A 0 IS REPRESENTED BY 4 SHORT PERIODS AND 1 LONG PERIOD.
0666                             ;L IS LOADED WITH DOUBLE THE LOW SPEED CYCLE COUNT AS IT IS USED TO COUNT THE HALF CYCLES
0666                             ;IN THE TONE ROUTINE. IF THE HIGH SPEED SAVE IS SELECTED, THEN THE CYCLE COUNT WILL BE
0666                             ;HALVED IN THE TONE ROUTINE.
0666                             ; 
0666   D9           SAVE_BIT:   EXX      ;SWAP REGISTERS
0667   26 00                  LD   H,0x00   ;ZERO H
0669   38 09                  JR   C,L0674   ;JUMP IF BINARY 1 IS TO BE OUTPUTTED
066B   2E 10                  LD   L,0x10   ;LOAD L WITH HIGH TONE CYCLE COUNT
066D   CD 84 06               CALL   HIGH_TONE   ;CALL HIGH TONE
0670   2E 04                  LD   L,0x04   ;LOAD L WITH LOW TONE CYCLE COUNT
0672   18 07                  JR   L067B   ;JUMP TO LOW TONE
0674   2E 08        L0674:    LD   L,0x08   ;LOAD L FOR HIGH TONE CYCLE COUNT
0676   CD 84 06               CALL   HIGH_TONE   ;FOR BINARY ONE: CALL HIGH TONE
0679   2E 08                  LD   L,0x08   ;LOAD L FOR LOW TONE CYCLE COUNT
067B   CD 80 06     L067B:    CALL   LOW_TONE   ;CALL LOW TONE
067E   D9                     EXX      ;SWAP BACK REGISTERS
067F   C9                     RET      ;DONE
0680                             ; 
0680                             ;SET-UP FOR LOW TONE (LONG PERIOD)
0680   0E 29        LOW_TONE:   LD   C,0x29   ;LOAD C FOR LOW TONE
0682   18 02                  JR   L0686   ;JUMP TO TONE ROUTINE
0684                             ; 
0684                             ;SET-UP FOR HIGH TONE (SHORT PERIOD)
0684   0E 11        HIGH_TONE:   LD   C,0x11   ;LOAD C FOR HIGH TONE
0686                             ; 
0686                             ;TONE ROUTINE
0686                             ;TESTS FOR LOWSPEED SAVE. IF SO THEN IT HALVES THE CYCLE COUNT IN L.
0686   3A 8F 08     L0686:    LD   A,(MENU_NO)   ;FIND WHICH SPEED
0689   B7                     OR   A   ;ZERO = HIGH SPEED
068A   20 02                  JR   NZ,L068E   ;JUMP IF LOW SPEED
068C   CB 3D                  SRL   L   ;ELSE HALVE CYCLE COUNT
068E   11 01 00     L068E:    LD   DE,0001H   ; 
0691   3E 84                  LD   A,0x84   ;TURN ON SPEAKER AND MIDDLE DISPLAY
0693   D3 01        L0693:    OUT   (DSCAN),A   ; 
0695   41                     LD   B,C   ; 
0696   10 FE        L0696:    DJNZ   L0696   ;PERIOD DELAY
0698   EE 80                  XOR   0x80   ;TOGGLE SPEAKER BIT
069A   ED 52                  SBC   HL,DE   ;DECREASE CYCLE COUNT
069C   20 F5                  JR   NZ,L0693   ;JUMP IF NOT ALL CYCLES DONE
069E   C9                     RET      ;ELSE RETURN
069F                             ; 
069F                             ;THIS ROUTINE SETS UP THE "ERR-IN DISPLAY ON THE PERIMETER HANDLER.
069F                          .ORG   $069F   
069F   21 52 07     ERR_ENTRY:   LD   HL,TAPE_ERRIN   ;POINT HL TO "Err-In" DISPLAY
06A2   11 00 08               LD   DE,DISP_BUFF   ;CODE AND DE TO RAM DEstination
06A5   01 06 00               LD   BC,0x0006   ;BC(ount)
06A8   ED B0                  LDIR      ;MOVE BLOCK
06AA   C3 50 00               JP   L0050   ;JUNE TO SOFT PERIMETER ENTRY
06AD                             ; 
06AD                             ;----END OF TAPE ROUTINES----
06AD                             ;THIS ROUTINE IS THE KEYBOARD READER/VALIDATER
06AD                             ;THE ACTION IS AS FOLLOWS:
06AD                             ;A SHORT LOOP LOOKS FOR A KEY PRESS. IF NO KEY IS PRESSED, THEN THE KEY PRESS BUFFER (0825)
06AD                             ;IS CLEARED THE ZERO AND THE CARRY FLAG CLEARED AND THE ROUTINE RETURNS.
06AD                             ;IF A KEY IS FOUND, THEN THE REMAINING LOOP COUNTS ARE WORKED OFF IN A DUMMY LOOP TO ENSURE
06AD                             ;EQUAL TIME IN EXECUTING THE ROUTINE.
06AD                             ;IF IT IS THE FIRST TIME.THAT THE KEY HAS BEEN DETECTED, THEN THE KEY PRESS FLAG WILL BE
06AD                             ;CLEAR. (IT WAS CLEARED BY THE MONITOR VARIABLES ON RESET). THE ROUTINE TESTS FOR THIS
06AD                             ;CONDITION AND IF TRUE THEN THE KEY IS ACCEPTED AS "VALID" AND FLAGGED BY A SET CARRY AND
06AD                             ;SET ZERO FLAG AND THE KEY PRESS FLAG IS SET TO INDICATE THE A KEY HAS BEEN DETECTED. THE
06AD                             ;INPUT IS THEN PLACED IN BOTH THE "I" REGISTER AND THE ACCUMULATOR. IF A KEY IS DETECTED
06AD                             ;BUT FOUND NOT TO BE VALID, I.E. IT HAS ALREADY BEEN DETECTED AND PROCESSED, THEN THE
06AD                             ;CARRY WILL BE SET BUT THE ZERO CLEARED. THIS ALLOWS THE AUTO KEY REPEAT SECTION TO KNOW
06AD                             ;THAT A KEY IS STILL BEING HELD DOWN. THE AUTO KEY REPEAT SECTION MAKE UP ITS OWN MIND
06AD                             ;WHETHER IT IS VALID OR NOT.
06AD                             ; 
06AD                          .ORG   $06AD   
06AD   DB 03        KEY_READ:   IN   A,(P_DAT)   ;TEST FOR KEY PRESSED
06AF   CB 77                  BIT   6,A   
06B1   28 08                  JR   Z,L06BB   ;DA IS LOW = KEYPRESS
06B3   10 F8                  DJNZ   KEY_READ   ;LOOP LOOKING FOR KEY UNTIL B=0
06B5   AF           L06B5:    XOR   A   ;CLEAR KEY PRESS FLAG
06B6   32 25 08               LD   (V_KEY_PRES),A   
06B9   3D                     DEC   A   ;SET A TO FF AND CLEAR ZERO FLAG
06BA   C9           L06BA:    RET      ;DONE
06BB   3A 25 08     L06BB:    LD   A,(V_KEY_PRES)   ;GET KEY PRESS FLAG
06BE   B7                     OR   A   ;TEST FOR ZERO
06BF   20 00                  JR   NZ,L06C1   ;DUMMY JUMP TO EQUALIZE TIME
06C1   10 F8        L06C1:    DJNZ   L06BB   ;FINISH LOOP
06C3   37                     SCF      ;SET CARRY
06C4   20 F4                  JR   NZ,L06BA   ;DUMMY JUMP TO RETURN
06C6   3D                     DEC   A   ;SET KEY PRESS FLAG TO FF
06C7   32 25 08               LD   (V_KEY_PRES),A   
06CA   DB 00        KEY_GET:   IN   A,(KEYBOARD)   ;GET INPUT KEY FROM ENCODER CHIP
06CC   E6 1F                  AND   0x1F   ;MASK OFF UNUSED BITS
06CE   CB 7F                  BIT   7,A   ;SET ZERO FLAG (THINK ABOUT IT!)
06D0   37                     SCF      ;SET CARRY
06D1   32 20 08               LD   (V_KEY),A   ;STORE INPUT KEY
06D4   C9                     RET      ;DONE
06D5                             ; 
06D5                             ;THIS ROUTINE IS CALLED ONCE ON EVERY HARD RESET. IT INITIALIZES THE LCD THEN TESTS THAT
06D5                             ;IT IS THERE (IT CANNOT DO IT THE OTHER WAY AROUND AS THE LCD NEEDS TO BE INITIALIZED
06D5                             ;BEFORE IT WILL RESPOND INTELLIGENTLY). IF THE LCD IS FITTED THEN THE ROUTINE WILL READ
06D5                             ;IN AN ASCII SPACE CHARACTER (20H) OR IF THE LCD IS NOT, JUNK FROM THE DATA BUSS.
06D5                             ;20H IS SUBTRACTED FROM WHATEVER IS READ IN AND THE RESULT IS STORED IN THE LCD ENABLE
06D5                             ;BUFFER. IF THE RESULT IS ZERO THEN THE LCD IS ENABLED. IT IS VITAL TO KNOW IF THE LCD IS
06D5                             ;FITTED, OTHERWISE THE ROUTINE WHICH READS THE BUSY FLAG MAY LOOP FOREVER.
06D5                             ; 
06D5   21 B5 07     LCD_RESET:   LD   HL,LCDRST_TBL   ;POINT HL TO LCD INITIALIZE TABLE
06D8   01 04 04               LD   BC,0x0404   ;B=4 BYTES, C=PORT 4
06DB   11 00 05     L06DB:    LD   DE,0500H   ;DELAY BETWEEN
06DE   1B           L06DE:    DEC   DE   ;EACH BYTE
06DF   7A                     LD   A,D   ;AS PER
06E0   B3                     OR   E   ;LCD MANUFACTER'S
06E1   20 FB                  JR   NZ,L06DE   ;INSTRUCTIONS
06E3   ED A3                  OUTI      ;OUTPUT (HL) TO (C). HL=HL=1,B=B-1
06E5   20 F4                  JR   NZ,L06DB   ;JUMP IF B NOT 0
06E7   10 FE        L06E7:    DJNZ   L06E7   ;SHORT DELAY
06E9   DB 84                  IN   A,(P_LCDDATA)   ;INPUT FROM LCD TO SEE IF IT'S THERE
06EB   D6 20                  SUB   0x20   ;SUBTRACT ASCII SPACE, IF LCD FITTED
06ED   32 21 08               LD   (V_LCD),A   ;RESULT WILL BE ZERO: STORE THIS IN
06F0   C9                     RET      ;LCD MASK: DONE
06F1                             ; 
06F1   FF FF FF FF FF FF      DB   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF   ;FILL 
06F7   FF FF FF FF FF FF      DB   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF   ;FILL 
06FD   FF FF FF               DB   0xFF,0xFF,0xFF   ;FILL 
0700                             ; 
0700                             ;AT 0700 IS THE TAPE'S MENU JUMP TABLE.
0700                          .ORG   0x0700   
0700                TAPE_JP_TBL:      
0700   C3 3F 04               JP   J_TAPE_SAVE   ;HIGH SPEED SAVE
0703   C3 3F 04               JP   J_TAPE_SAVE   ;LOW SPEED SAVE
0706   C3 37 04               JP   J_TAPE_TEST   ;TEST BLOCK
0709   C3 3B 04               JP   J_TAPE_CHKS   ;TEST CHECKSUM
070C   C3 26 04               JP   J_TAPE_LOAD   ;LOAD TAPE
070F                             ; 
070F                             ;BELOW ARE THE JMON DEFAULT RESET VARIABLES (A ZERO IS THE ACTIVE RAM
070F                             ;STATE UNLESS OTHERWISE STATED). LOCATION
070F                             ;* DENOTES CONTROL BYTES DESIGNED TO BE USER ALTERED (IN RAM).
070F                             ; 
070F                          .ORG   $070F   
070F   00           DEF_VARS:   DB   0x00   ;KEY BUFFER 0820
0710   00           L0710:    DB   0x00   ;LCD ON/OFF FLAG 0821*
0711   00           L0711:    DB   0x00   ;SOUND ON/OFF 0822*
0712   FF           L0712:    DB   0xFF   ;GO AT ALTERNATE GO ADDRESS IF AA 0823*
0713   FF           L0713:    DB   0xFF   ;STEPPER KEY CONTROL/TIMER 0824
0714   00           L0714:    DB   0x00   ;KEY PRESSED FLAG 0825
0715   FF           L0715:    DB   0xFF   ;UNUSED 0826
0716   00           L0716:    DB   0x00   ;AUTO INCREMENT ON/OFF 0827*
0717   00 0A        L0717:    DB   0x00,0x0A   ;ALT GO ADDR/SOFT RESET EDIT LOCATION ($1000) 0828*
0719   70           L0719:    DB   0x70   ;AUTO KEY REPEAT TIMER 082A
071A   00           L071A:    DB   0x00   ;MONITOR CONTROL BYTE 082B
071B   00 08        L071B:    DB   0x00,0x08   ;DISPLAY BUFFER ADDRESS 082C*
071D   00 09        L071D:    DB   0x00,0x09   ;INITIAL EDITING LOCATION 082E
071F                             ; 
071F                             ;BELOW ARE THE JMON INDIRECT JUMP ADDRESSES. THIS TABLE IS SHIFTED DOWN TO 0830 ON A HARD RESET.
071F   C3 D5 01     L071F:    JP   J_HL2CODE   ;CONVERT HL TO DISPLAY CODE 0830
0722   C3 DA 01     L0722:    JP   J_A2CODE   ;CONVERT A TO DISPLAY CODE 0833
0725   C3 BA 01     L0725:    JP   J_LEDSCAN   ;LED SCAN ROUTINE 0836
0728   C3 EE 01     L0728:    JP   J_SETDOTS   ;SET LED DOTS 0839
072B   C3 24 02     L072B:    JP   J_TONEX2   ;RESET TONES 083C
072E   C3 27 02     L072E:    JP   J_TONE   ;TONE 083F
0731   C3 81 01     L0731:    JP   J_SCANKEY   ;SCAN/KEY/LCD/PATCH LOOP 0842
0734   C3 B2 00     L0734:    JP   J_DISPUPD   ;SOFT JMON ENTRY L0845
0737   C3 3C 02     L0737:    JP   J_LCD   ;LCD ROUTINE 0848
073A                             ; 
073A                             ;BELOW ARE THE DISPLAY TABLES FOR THE TAPE'S MENU ADDRESS DISPLAYS AND
073A                             ;THE "ERR-IN" DISPLAY THAT IS SUPERIMPOSED OVER THE PERIMETER HANDLER.
073A                TAPE_AD_TBL:      
073A   A7 6F EA C7            DB   0xA7,0x6F,0xEA,0xC7   ;"SAVE"
073E   A7 6F EA C7            DB   0xA7,0x6F,0xEA,0xC7   ;"SAVE"
0742   C6 C7 A7 C6            DB   0xC6,0xC7,0xA7,0xC6   ;"TEST"
0746   C6 C7 A7 C6            DB   0xC6,0xC7,0xA7,0xC6   ;"TEST"
074A   C2 EB 6F EC            DB   0xC2,0xEB,0x6F,0xEC   ;"LOAD"
074E                             ; 
074E   04 C7 64 EC  L074E:    DB   0x04,0xC7,0x64,0xEC   ;"-End"
0752   04 C7 44 44 28 64 TAPE_ERRIN:   DB   0x04,0xC7,0x44,0x44,0x28,0x64   ;"-Err In"
0758   4F 6F A7 A7            DB   0x4F,0x6F,0xA7,0xA7   ;"PASS"
075C   47 6F 28 C2  TAPE_FAIL:   DB   0x47,0x6F,0x28,0xC2   ;"FAIL"
0760                             ; 
0760                             ;BELOW ARE THE TAPE'S MENU DATA DISPLAYS.
0760                TAPE_DA_TBL:      
0760   04 6E                  DB   0x04,0x6E   ;"-H"
0762   04 C2                  DB   0x04,0xC2   ;"-L"
0764   E6 C2                  DB   0xE6,0xC2   ;"bL"
0766   C3 A7                  DB   0xC3,0xA7   ;"CS"
0768                TAPE_FDA_TBL:      
0768   04 C6                  DB   0x04,0xC6   ;"-t" Used for last menu and first failed menu
076A   04 A7                  DB   0x04,0xA7   ;"-S"
076C   C6 E6                  DB   0xC6,0xE6   ;"tb"
076E   C3 A7                  DB   0xC3,0xA7   ;"CS"
0770   C2 EC                  DB   0xC2,0xEC   ;"Ld"
0772                             ; 
0772   FF FF FF FF FF FF FF FF FF FF L0772:   DB   0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF   ;(UNUSED)
077C                             ; 
077C                             ;BELOW IS THE PERIMETER HANDLER COMMAND STRING FOR THE TAPE SOFTWARE.
077C                          .ORG   $077C   
077C                TAPE_P_DRIVER:      
077C   FF FF                  DB   0xFF,0xFF   ;BLANK
077E   C6 07                  DW   PERM_DA_TBL   ;LED DISPLAY FOR DATA, 2 BYTES EACH
0780   99 08                  DB   0x99,0x08   ;STORE KEYED INFO HERE AT 0X0898
0782   00 03                  DB   0x00,0x03   ;NUMBER OF PERIMETER ITEMS, =4
0784   FF FF                  DB   0xFF,0xFF   ;FUNCTION TO CALL WHEN GO PRESSED (FILLED IN BY MENU)
0786                             ;SEE 0426-044E).
0786                             ; 
0786                             ;0786 - 0788 FF ;(RESERVED FOR COMMAND STRING EXPANSION).
0786   FF FF FF               DB   0xFF,0xFF,0xFF   
0789                             ; 
0789                             ;BELOW IS THE TAPE'S MENU DRIVER COMMAND STRING.
0789                          .ORG   $0789   
0789                TAPE_M_DRIVER:      
0789   FF FF                  DB   0xFF,0xFF   ;BLANK
078B   00 04                  DB   0x00,0x04   ;FIRST MENU ITEM AND TOTAL NUMBER IF ENTRIES
078D   00 07                  DW   TAPE_JP_TBL   ;JUMP TABLE FOR MENU ITEMS
078F   3A 07                  DW   TAPE_AD_TBL   ;MENU ADDRESS LED DISPLAY TABLE
0791   60 07                  DW   TAPE_DA_TBL   ;MENU DATA LED DISPLAY TABLE
0793   C9                     DB   0xC9   ;TAPE'S SOFTWARE MENU DATA KEY HANDLER
0794                             ;ROUTINE JUMP VECTOR (A RETURN INSTRUCTION).
0794                             ;BELOW IS THE STEPPERS DATA DISPLAY CODES.
0794                          .ORG   $0794   
0794   4F C3        SEGREG_TBL:   DB   0x4F,0xC3   ;"PC"
0796   6F 47                  DB   0x6F,0x47   ;"AF"
0798   E6 C3                  DB   0xE6,0xC3   ;"BC"
079A   EC C7                  DB   0xEC,0xC7   ;"DE"
079C   6E C2                  DB   0x6E,0xC2   ;"HL"
079E   28 6E                  DB   0x28,0x6E   ;"IX"
07A0   28 AE                  DB   0x28,0xAE   ;"IY"
07A2   7F 57                  DB   0x7F,0x57   ;“AF'"
07A4   F6 D3                  DB   0xF6,0xD3   ;"BC'"
07A6   FC D7                  DB   0xFC,0xD7   ;"DE'"
07A8   7E D2                  DB   0x7E,0xD2   ;"HL'"
07AA   A7 4F                  DB   0xA7,0x4F   ;"SP"
07AC   FF                     DB   0xFF   ;(UNUSED)
07AD                             ; 
07AD                             ;START OF STAGGERED TABLE OF JMON MODE WORDS FOR LCD
07AD                          .ORG   $07AD   
07AD   44 61 74 61  LCDFNC_TBL:   DB   0x44,0x61,0x74,0x61   ;"Data"
07B1   41 64 64 72            DB   0x41,0x64,0x64,0x72   ;"Addr"
07B5                             ; 
07B5                             ;LCD INITIALIZATION CODES
07B5                          .ORG   $07B5   
07B5   38 01 06 0C  LCDRST_TBL:   DB   0x38,0x01,0x06,0x0C   ;0X38 - 8-BIT MODE, 2 LINES, 5x8 DOTS
07B9                             ;0x01 - CLEAR DISPLAY
07B9                             ;0x06 - CURSOR TO RIGHT,NO SHIFT
07B9                             ;0x0C - DISPLAY ON, CURSOR OFF
07B9                             ; 
07B9                             ;THE REST OF THE JMON MODE WORD TABLE FOR LCD *THIS TABLE NEEDS TO BE 12 BYTES FROM LCDFNC_TBL
07B9                          .ORG   $07B9   
07B9   46 73 2D 20  L07B9:    DB   0x46,0x73,0x2D,0x20   ;"Fs- "
07BD                             ; 
07BD                             ;ADDRESS TABLE OF THE LCD PROMPT LOCATIONS.
07BD                          .ORG   $07BD   
07BD   84 87 8A 8D C4 C7 CA CD 80 LCDPMT_TBL:   DB   0x84,0x87,0x8A,0x8D,0xC4,0xC7,0xCA,0xCD,0x80   
07C6                             ; 
07C6                             ;TAPE'S PERIMETER HANDLER DATA DISPLAYS
07C6                          .ORG   $07C6   
07C6                PERM_DA_TBL:      
07C6   04 47                  DB   0x04,0x47   ;"-F"
07C8   04 A7                  DB   0x04,0xA7   ;"-S"
07CA   04 C7                  DB   0x04,0xC7   ;"-E"
07CC   04 E3                  DB   0x04,0xE3   ;"-G"
07CE   FF FF                  DB   0xFF,0xFF   ;(UNUSED)
07D0                             ; 
07D0                             ;BELOW ARE THE DISPLAY CODE EQUIVALENTS OF THE HEX DIGITS 0 TO F LISTED IN ASCENDING ORDER.
07D0                          .ORG   $07D0   
07D0   EB 28 CD AD 2E A7 E7 29 EF 2F 6F E6 C3 EC SEG_TBL:   DB   0xEB,0x28,0xCD,0xAD,0x2E,0xA7,0xE7,0x29,0xEF,0x2F,0x6F,0xE6,0xC3,0xEC   
07DE   C7 47                  DB   0xC7,0x47   ;MJ: Split out to allow for a Label that is used
07E0                             ; 
07E0                             ;FINALLY AT 07E0 IS THE FUNCTION-1 AND SHIFT JUMP ADDRESSES.  ACCESS BY PRESSING "SHIFT" + "NUMBER"
07E0                             ;OR "ADDRESS", then "+", then "NUMBER" TO ENTER FUNCTION-! MODE
07E0                          .ORG   $07E0   
07E0   D2 03        L07E0:    DW   FN_TAPE   ;#0 TAPE MENU SETUP TO MENU DRIVER
07E2   E3 02                  DW   FN_BACK1   ;#1 MOVE ADDRESS BACK ONE LOCATION
07E4   5E 00                  DW   FN_STEPPER   ;#2 STEPPER ROUTINE
07E6   FF FF                  DW   0xFFFF   ;#3 N/A
07E8   D3 02                  DW   FN_FORW4   ;#4 MOVE ADDRESS FORWARD FOUR LOCATIONS
07EA   AE 00                  DW   FN_S_RST   ;#5 DO A SOFT RESET
07EC   DE 02                  DW   FN_BACK4   ;#6 MOVE ADDRESS BACK FOUR LOCATIONS
07EE   41 03                  DW   FN_REGDIS   ;#7 DISPLAY REGISTERS
07F0   ED 02                  DW   FN_FORW8   ;#8 MOVE ADDRESS FORWARD EIGHT LOCATIONS
07F2   E8 02                  DW   FN_FORW1   ;#9 MOVE ADDRESS FORWARD ONE LOCATION
07F4   F2 02                  DW   FN_BACK8   ;#A MOVE ADDRESS BACK EIGHT LOCATIONS
07F6   FF FF                  DW   0xFFFF   ;#B N/A
07F8   FF FF                  DW   0xFFFF   ;#C N/A
07FA   FF FF                  DW   0xFFFF   ;#D N/A
07FC   FF FF                  DW   0xFFFF   ;#E N/A
07FE   FF FF                  DW   0xFFFF   ;#F N/A


REG_TBL:            0792 DEFINED AT LINE 97
                    > USED AT LINE 910
DISP_BUFF:          0800 DEFINED AT LINE 98
                    > USED AT LINE 1030
                    > USED AT LINE 1061
                    > USED AT LINE 1234
                    > USED AT LINE 1442
                    > USED AT LINE 1731
DISP_DBUFF:         0804 DEFINED AT LINE 99
                    > USED AT LINE 1224
DISP_D2BUF:         0805 DEFINED AT LINE 100
                    > USED AT LINE 1446
DISP_STEP:          0806 DEFINED AT LINE 101
                    > USED AT LINE 870
V_KEY:              0820 DEFINED AT LINE 104
                    > USED AT LINE 292
                    > USED AT LINE 304
                    > USED AT LINE 425
                    > USED AT LINE 433
                    > USED AT LINE 473
                    > USED AT LINE 520
                    > USED AT LINE 538
                    > USED AT LINE 1774
V_LCD:              0821 DEFINED AT LINE 105
                    > USED AT LINE 655
                    > USED AT LINE 1797
V_BEEP:             0822 DEFINED AT LINE 106
                    > USED AT LINE 634
V_ALT_ADDF:         0823 DEFINED AT LINE 107
                    > USED AT LINE 377
V_STEP_TMR:         0824 DEFINED AT LINE 108
                    > USED AT LINE 920
                    > USED AT LINE 1015
V_KEY_PRES:         0825 DEFINED AT LINE 109
                    > USED AT LINE 1759
                    > USED AT LINE 1762
                    > USED AT LINE 1769
V_SPARE1:           0826 DEFINED AT LINE 110
V_AUTO:             0827 DEFINED AT LINE 111
                    > USED AT LINE 416
                    > USED AT LINE 618
                    > USED AT LINE 725
V_ALT_ADDR:         0828 DEFINED AT LINE 112
                    > USED AT LINE 195
                    > USED AT LINE 382
V_KAUTO:            082A DEFINED AT LINE 113
                    > USED AT LINE 525
V_MCB:              082B DEFINED AT LINE 114
                    > USED AT LINE 325
                    > USED AT LINE 343
                    > USED AT LINE 365
                    > USED AT LINE 424
                    > USED AT LINE 501
                    > USED AT LINE 596
                    > USED AT LINE 727
V_DISPLAY:          082C DEFINED AT LINE 115
                    > USED AT LINE 331
                    > USED AT LINE 546
                    > USED AT LINE 595
                    > USED AT LINE 871
                    > USED AT LINE 899
                    > USED AT LINE 1031
V_CEL:              082E DEFINED AT LINE 116
                    > USED AT LINE 273
                    > USED AT LINE 286
                    > USED AT LINE 330
                    > USED AT LINE 341
                    > USED AT LINE 358
                    > USED AT LINE 380
                    > USED AT LINE 420
                    > USED AT LINE 440
                    > USED AT LINE 672
                    > USED AT LINE 722
                    > USED AT LINE 786
                    > USED AT LINE 788
HL_2_DIS:           0830 DEFINED AT LINE 121
                    > USED AT LINE 332
                    > USED AT LINE 900
                    > USED AT LINE 1235
                    > USED AT LINE 1444
A_2_DISP:           0833 DEFINED AT LINE 122
                    > USED AT LINE 334
                    > USED AT LINE 566
LED_SCAN:           0836 DEFINED AT LINE 123
                    > USED AT LINE 227
                    > USED AT LINE 518
                    > USED AT LINE 1449
SET_DOTS:           0839 DEFINED AT LINE 124
                    > USED AT LINE 335
BEEPBEEP:           083C DEFINED AT LINE 125
                    > USED AT LINE 323
BEEP:               083F DEFINED AT LINE 126
                    > USED AT LINE 536
                    > USED AT LINE 630
SCAN_IO:            0842 DEFINED AT LINE 127
                    > USED AT LINE 336
                    > USED AT LINE 1084
                    > USED AT LINE 1246
DO_DISP:            0845 DEFINED AT LINE 128
                    > USED AT LINE 383
LCD_DISP:           0848 DEFINED AT LINE 129
                    > USED AT LINE 516
PATCH_BEF:          084B DEFINED AT LINE 132
                    > USED AT LINE 517
PATCH_DUR:          084E DEFINED AT LINE 133
                    > USED AT LINE 519
PATCH_AFT:          0851 DEFINED AT LINE 134
                    > USED AT LINE 535
STEP_NEXT:          0858 DEFINED AT LINE 135
                    > USED AT LINE 240
                    > USED AT LINE 274
                    > USED AT LINE 838
                    > USED AT LINE 842
STEP_CREG:          085A DEFINED AT LINE 136
                    > USED AT LINE 877
                    > USED AT LINE 880
                    > USED AT LINE 906
                    > USED AT LINE 946
RE_ENTRY:           0860 DEFINED AT LINE 137
                    > USED AT LINE 837
                    > USED AT LINE 859
STEP_PREV:          0868 DEFINED AT LINE 138
                    > USED AT LINE 839
STEP_REGS:          086A DEFINED AT LINE 139
                    > USED AT LINE 862
HL_SAVE:            086E DEFINED AT LINE 140
                    > USED AT LINE 194
STEP_HL:            0870 DEFINED AT LINE 141
                    > USED AT LINE 833
STEP_SP:            087E DEFINED AT LINE 142
                    > USED AT LINE 840
                    > USED AT LINE 843
                    > USED AT LINE 1004
PERI_MENU:          0880 DEFINED AT LINE 143
                    > USED AT LINE 1027
PERI_D_TBL:         0882 DEFINED AT LINE 144
                    > USED AT LINE 1202
PERI_W_ADD:         0884 DEFINED AT LINE 145
                    > USED AT LINE 1201
PERI_W_CUR:         0886 DEFINED AT LINE 146
                    > USED AT LINE 1154
                    > USED AT LINE 1200
                    > USED AT LINE 1247
PERI_W_MAX:         0887 DEFINED AT LINE 147
                    > USED AT LINE 1152
PERI_J_ADR:         0888 DEFINED AT LINE 148
                    > USED AT LINE 1151
                    > USED AT LINE 1250
TAPE_ACTN:          088A DEFINED AT LINE 149
                    > USED AT LINE 1128
                    > USED AT LINE 1516
                    > USED AT LINE 1573
PERI_W_AC1:         088C DEFINED AT LINE 150
                    > USED AT LINE 1216
                    > USED AT LINE 1287
MENU_NO:            088F DEFINED AT LINE 151
                    > USED AT LINE 1048
                    > USED AT LINE 1085
                    > USED AT LINE 1093
                    > USED AT LINE 1533
                    > USED AT LINE 1714
MENU_J_TBL:         0891 DEFINED AT LINE 152
                    > USED AT LINE 1092
MENU_A_TBL:         0893 DEFINED AT LINE 153
                    > USED AT LINE 1050
MENU_D_TBL:         0895 DEFINED AT LINE 154
                    > USED AT LINE 1049
MENU_KEYRN:         0897 DEFINED AT LINE 155
                    > USED AT LINE 1088
TAPE_FILE:          0898 DEFINED AT LINE 156
                    > USED AT LINE 1175
                    > USED AT LINE 1465
TAPE_START:         089A DEFINED AT LINE 157
                    > USED AT LINE 1131
                    > USED AT LINE 1166
                    > USED AT LINE 1475
TAPE_END:           089C DEFINED AT LINE 158
                    > USED AT LINE 1169
TAPE_AUTOG:         089E DEFINED AT LINE 159
                    > USED AT LINE 1164
                    > USED AT LINE 1183
TAPE_O_FIL:         08A4 DEFINED AT LINE 160
                    > USED AT LINE 1176
                    > USED AT LINE 1359
                    > USED AT LINE 1437
                    > USED AT LINE 1443
                    > USED AT LINE 1471
TAPE_O_STA:         08A6 DEFINED AT LINE 161
                    > USED AT LINE 1167
                    > USED AT LINE 1365
                    > USED AT LINE 1481
TAPE_O_LEN:         08A8 DEFINED AT LINE 162
                    > USED AT LINE 1174
                    > USED AT LINE 1390
                    > USED AT LINE 1490
                    > USED AT LINE 1559
TAPE_O_GO:          08AA DEFINED AT LINE 163
                    > USED AT LINE 1165
                    > USED AT LINE 1510
PATCH_REQ:          08B0 DEFINED AT LINE 164
                    > USED AT LINE 814
PATCH_STA:          08B1 DEFINED AT LINE 165
                    > USED AT LINE 818
PATCH_VAR:          08B3 DEFINED AT LINE 166
                    > USED AT LINE 817
PATCH_CHK:          08B5 DEFINED AT LINE 167
                    > USED AT LINE 823
PATCH_ADR:          08B6 DEFINED AT LINE 168
                    > USED AT LINE 826
USER_TBL:           08BE DEFINED AT LINE 169
                    > USED AT LINE 468
RST_FLAG:           08FF DEFINED AT LINE 170
                    > USED AT LINE 296
                    > USED AT LINE 316
JMON_UTIL:          3800 DEFINED AT LINE 171
                    > USED AT LINE 319
                    > USED AT LINE 322
JMON_UJMP:          381E DEFINED AT LINE 172
                    > USED AT LINE 472
KEYBOARD:           0000 DEFINED AT LINE 175
                    > USED AT LINE 405
                    > USED AT LINE 1770
DSCAN:              0001 DEFINED AT LINE 176
                    > USED AT LINE 550
                    > USED AT LINE 556
                    > USED AT LINE 640
                    > USED AT LINE 1645
                    > USED AT LINE 1651
                    > USED AT LINE 1720
DSEGMENT:           0002 DEFINED AT LINE 177
                    > USED AT LINE 548
                    > USED AT LINE 559
                    > USED AT LINE 1554
P_DAT:              0003 DEFINED AT LINE 180
                    > USED AT LINE 1640
                    > USED AT LINE 1646
                    > USED AT LINE 1754
P_LCDDATA:          0084 DEFINED AT LINE 181
                    > USED AT LINE 683
                    > USED AT LINE 709
                    > USED AT LINE 741
                    > USED AT LINE 1795
P_LCDINST:          0004 DEFINED AT LINE 182
                    > USED AT LINE 248
                    > USED AT LINE 659
                    > USED AT LINE 663
                    > USED AT LINE 738
                    > USED AT LINE 754
K_PLUS:             0010 DEFINED AT LINE 185
                    > USED AT LINE 348
                    > USED AT LINE 948
                    > USED AT LINE 1269
K_MINUS:            0011 DEFINED AT LINE 186
                    > USED AT LINE 367
                    > USED AT LINE 962
                    > USED AT LINE 1271
K_GO:               0012 DEFINED AT LINE 187
                    > USED AT LINE 373
                    > USED AT LINE 975
                    > USED AT LINE 1277
K_ADDR:             0013 DEFINED AT LINE 188
                    > USED AT LINE 1009
                    > USED AT LINE 1273
RST08:              0008 DEFINED AT LINE 203
                    > USED AT LINE 204
RST10:              0010 DEFINED AT LINE 210
                    > USED AT LINE 211
RST18:              0018 DEFINED AT LINE 225
RST20:              0020 DEFINED AT LINE 231
RST28:              0028 DEFINED AT LINE 239
RST30:              0030 DEFINED AT LINE 248
                    > USED AT LINE 250
RST38:              0038 DEFINED AT LINE 256
L0041:              0041 DEFINED AT LINE 260
L0044:              0044 DEFINED AT LINE 261
L0047:              0047 DEFINED AT LINE 262
                    > USED AT LINE 1539
L004A:              004A DEFINED AT LINE 263
                    > USED AT LINE 1173
L004D:              004D DEFINED AT LINE 264
L0050:              0050 DEFINED AT LINE 265
                    > USED AT LINE 1734
FN_STEPPER:         005E DEFINED AT LINE 273
                    > USED AT LINE 1950
MON_START:          006B DEFINED AT LINE 285
                    > USED AT LINE 196
MON_START2:         0076 DEFINED AT LINE 292
                    > USED AT LINE 287
HARD_RST:           0086 DEFINED AT LINE 303
                    > USED AT LINE 295
L0095:              0095 DEFINED AT LINE 309
                    > USED AT LINE 313
SOFT_RST:           00A2 DEFINED AT LINE 319
                    > USED AT LINE 298
FN_S_RST:           00AE DEFINED AT LINE 324
                    > USED AT LINE 1953
J_DISPUPD:          00B2 DEFINED AT LINE 330
                    > USED AT LINE 366
                    > USED AT LINE 1840
KEY_MGMT:           00C6 DEFINED AT LINE 340
KEY_PLUS:           00D3 DEFINED AT LINE 348
L00D8:              00D8 DEFINED AT LINE 358
                    > USED AT LINE 372
L00DC:              00DC DEFINED AT LINE 364
                    > USED AT LINE 397
L00E1:              00E1 DEFINED AT LINE 366
                    > USED AT LINE 444
KEY_MINUS:          00E3 DEFINED AT LINE 367
                    > USED AT LINE 349
KEY_GO:             00EA DEFINED AT LINE 373
                    > USED AT LINE 368
L00FA:              00FA DEFINED AT LINE 382
                    > USED AT LINE 379
L00FD:              00FD DEFINED AT LINE 383
                    > USED AT LINE 381
                    > USED AT LINE 483
KEY_ADDR:           0102 DEFINED AT LINE 390
                    > USED AT LINE 347
                    > USED AT LINE 374
L010D:              010D DEFINED AT LINE 396
                    > USED AT LINE 394
L0111:              0111 DEFINED AT LINE 400
                    > USED AT LINE 391
KEY_DATA:           011C DEFINED AT LINE 410
L012F:              012F DEFINED AT LINE 421
                    > USED AT LINE 418
L0132:              0132 DEFINED AT LINE 423
                    > USED AT LINE 414
KEY_CTRL:           013B DEFINED AT LINE 433
                    > USED AT LINE 402
L014C:              014C DEFINED AT LINE 443
                    > USED AT LINE 426
L014E:              014E DEFINED AT LINE 444
                    > USED AT LINE 502
KEY_FUNC:           0150 DEFINED AT LINE 464
                    > USED AT LINE 407
                    > USED AT LINE 437
L0162:              0162 DEFINED AT LINE 473
                    > USED AT LINE 467
                    > USED AT LINE 471
L0167:              0167 DEFINED AT LINE 476
                    > USED AT LINE 478
ENC_FUNC:           0171 DEFINED AT LINE 493
                    > USED AT LINE 435
J_SCANKEY:          0181 DEFINED AT LINE 515
                    > USED AT LINE 1839
L0187:              0187 DEFINED AT LINE 518
                    > USED AT LINE 528
                    > USED AT LINE 533
L019F:              019F DEFINED AT LINE 529
                    > USED AT LINE 526
L01AB:              01AB DEFINED AT LINE 535
                    > USED AT LINE 541
L01B6:              01B6 DEFINED AT LINE 540
                    > USED AT LINE 531
J_LEDSCAN:          01BA DEFINED AT LINE 544
                    > USED AT LINE 1835
L01BF:              01BF DEFINED AT LINE 547
                    > USED AT LINE 558
L01C7:              01C7 DEFINED AT LINE 552
                    > USED AT LINE 552
J_HL2CODE:          01D5 DEFINED AT LINE 564
                    > USED AT LINE 1833
J_A2CODE:           01DA DEFINED AT LINE 570
                    > USED AT LINE 1834
L01E3:              01E3 DEFINED AT LINE 578
                    > USED AT LINE 576
J_SETDOTS:          01EE DEFINED AT LINE 593
                    > USED AT LINE 1836
L0200:              0200 DEFINED AT LINE 602
                    > USED AT LINE 604
                    > USED AT LINE 615
L0206:              0206 DEFINED AT LINE 607
                    > USED AT LINE 600
L020F:              020F DEFINED AT LINE 612
                    > USED AT LINE 620
                    > USED AT LINE 622
                    > USED AT LINE 625
L0210:              0210 DEFINED AT LINE 613
                    > USED AT LINE 611
L0211:              0211 DEFINED AT LINE 614
                    > USED AT LINE 609
L0214:              0214 DEFINED AT LINE 616
                    > USED AT LINE 598
J_TONEX2:           0224 DEFINED AT LINE 629
                    > USED AT LINE 1837
J_TONE:             0227 DEFINED AT LINE 632
                    > USED AT LINE 1838
L0231:              0231 DEFINED AT LINE 640
                    > USED AT LINE 645
L0234:              0234 DEFINED AT LINE 642
                    > USED AT LINE 642
J_LCD:              023C DEFINED AT LINE 654
                    > USED AT LINE 1841
LCD_LINE1:          0253 DEFINED AT LINE 672
                    > USED AT LINE 661
LCD_LINE2:          025A DEFINED AT LINE 680
                    > USED AT LINE 665
L025F:              025F DEFINED AT LINE 682
                    > USED AT LINE 688
HL_2_LCD:           026C DEFINED AT LINE 692
                    > USED AT LINE 680
A_2_LCD:            0271 DEFINED AT LINE 697
                    > USED AT LINE 686
                    > USED AT LINE 693
LCD_NIBBLE:         027A DEFINED AT LINE 704
                    > USED AT LINE 702
LCD_OUT:            0282 DEFINED AT LINE 709
                    > USED AT LINE 777
LCD_PROMPT:         0286 DEFINED AT LINE 722
                    > USED AT LINE 666
L029B:              029B DEFINED AT LINE 733
                    > USED AT LINE 729
                    > USED AT LINE 731
L02C1:              02C1 DEFINED AT LINE 767
                    > USED AT LINE 769
                    > USED AT LINE 773
L02C7:              02C7 DEFINED AT LINE 772
                    > USED AT LINE 766
FN_FORW4:           02D3 DEFINED AT LINE 785
                    > USED AT LINE 1952
L02D6:              02D6 DEFINED AT LINE 786
                    > USED AT LINE 792
                    > USED AT LINE 794
                    > USED AT LINE 796
                    > USED AT LINE 798
                    > USED AT LINE 800
FN_BACK4:           02DE DEFINED AT LINE 791
                    > USED AT LINE 1954
FN_BACK1:           02E3 DEFINED AT LINE 793
                    > USED AT LINE 1949
FN_FORW1:           02E8 DEFINED AT LINE 795
                    > USED AT LINE 1957
FN_FORW8:           02ED DEFINED AT LINE 797
                    > USED AT LINE 1956
FN_BACK8:           02F2 DEFINED AT LINE 799
                    > USED AT LINE 1958
RST_PATCH:          02F7 DEFINED AT LINE 814
                    > USED AT LINE 293
L0305:              0305 DEFINED AT LINE 820
                    > USED AT LINE 822
STEPPER:            0312 DEFINED AT LINE 833
                    > USED AT LINE 256
SAVE_REGS:          0318 DEFINED AT LINE 837
                    > USED AT LINE 288
FN_REGDIS:          0341 DEFINED AT LINE 861
                    > USED AT LINE 1955
STEP_CONT:          0344 DEFINED AT LINE 870
                    > USED AT LINE 834
L034C:              034C DEFINED AT LINE 876
                    > USED AT LINE 960
L0351:              0351 DEFINED AT LINE 880
                    > USED AT LINE 959
                    > USED AT LINE 970
                    > USED AT LINE 972
L0358:              0358 DEFINED AT LINE 887
                    > USED AT LINE 890
L0373:              0373 DEFINED AT LINE 911
                    > USED AT LINE 913
STEP_DISP:          0379 DEFINED AT LINE 919
                    > USED AT LINE 931
                    > USED AT LINE 933
                    > USED AT LINE 1016
STEP_KEY:           038A DEFINED AT LINE 944
                    > USED AT LINE 921
STEP_PLUS:          0391 DEFINED AT LINE 948
STEP_MINUS:         039D DEFINED AT LINE 962
                    > USED AT LINE 949
STEP_GO:            03A8 DEFINED AT LINE 975
                    > USED AT LINE 963
STEP_DO_GO:         03AC DEFINED AT LINE 987
                    > USED AT LINE 938
                    > USED AT LINE 988
STEP_AD:            03C6 DEFINED AT LINE 1009
                    > USED AT LINE 976
STEP_DATA:          03CB DEFINED AT LINE 1014
                    > USED AT LINE 1010
FN_TAPE:            03D2 DEFINED AT LINE 1025
                    > USED AT LINE 1948
MENU_RTN:           03DD DEFINED AT LINE 1030
                    > USED AT LINE 260
MENU_DISP:          03E3 DEFINED AT LINE 1048
                    > USED AT LINE 1089
MENU_RTNT:          03E6 DEFINED AT LINE 1049
                    > USED AT LINE 1420
MENU_SFT:           03ED DEFINED AT LINE 1051
                    > USED AT LINE 262
L03F3:              03F3 DEFINED AT LINE 1054
                    > USED AT LINE 1058
L03F9:              03F9 DEFINED AT LINE 1059
                    > USED AT LINE 1053
MENU_GO:            0416 DEFINED AT LINE 1092
                    > USED AT LINE 1087
L041F:              041F DEFINED AT LINE 1096
                    > USED AT LINE 1100
L0425:              0425 DEFINED AT LINE 1101
                    > USED AT LINE 1095
J_TAPE_LOAD:        0426 DEFINED AT LINE 1124
                    > USED AT LINE 1811
L0427:              0427 DEFINED AT LINE 1128
                    > USED AT LINE 1138
J_TAPE_TEST:        0437 DEFINED AT LINE 1136
                    > USED AT LINE 1809
L0439:              0439 DEFINED AT LINE 1138
                    > USED AT LINE 1143
J_TAPE_CHKS:        043B DEFINED AT LINE 1141
                    > USED AT LINE 1810
J_TAPE_SAVE:        043F DEFINED AT LINE 1146
                    > USED AT LINE 1807
                    > USED AT LINE 1808
L0444:              0444 DEFINED AT LINE 1151
                    > USED AT LINE 1133
TAPE_SAVE_SETUP:    0450 DEFINED AT LINE 1163
                    > USED AT LINE 1147
L0473:              0473 DEFINED AT LINE 1182
                    > USED AT LINE 1155
PERI_RTN:           0479 DEFINED AT LINE 1200
                    > USED AT LINE 261
                    > USED AT LINE 1286
                    > USED AT LINE 1292
L0486:              0486 DEFINED AT LINE 1205
                    > USED AT LINE 1210
L048D:              048D DEFINED AT LINE 1216
                    > USED AT LINE 1204
PERI_SFT:           04A3 DEFINED AT LINE 1246
                    > USED AT LINE 265
MENU_KEY:           04B2 DEFINED AT LINE 1269
                    > USED AT LINE 1086
                    > USED AT LINE 1248
L04C0:              04C0 DEFINED AT LINE 1277
                    > USED AT LINE 1274
PERI_D_KEY:         04C4 DEFINED AT LINE 1286
                    > USED AT LINE 1249
MENU_K_HDL:         04D1 DEFINED AT LINE 1319
                    > USED AT LINE 1270
                    > USED AT LINE 1272
L04DB:              04DB DEFINED AT LINE 1328
                    > USED AT LINE 1325
L04E0:              04E0 DEFINED AT LINE 1332
                    > USED AT LINE 1340
                    > USED AT LINE 1343
L04E5:              04E5 DEFINED AT LINE 1337
                    > USED AT LINE 1331
L04EC:              04EC DEFINED AT LINE 1341
                    > USED AT LINE 1338
TAPE_SAVE:          04F0 DEFINED AT LINE 1357
                    > USED AT LINE 1177
START_BLK:          0508 DEFINED AT LINE 1390
                    > USED AT LINE 1414
L0516:              0516 DEFINED AT LINE 1402
                    > USED AT LINE 1392
END_BLOCK:          0526 DEFINED AT LINE 1417
                    > USED AT LINE 1395
TAPE_INPUT:         0531 DEFINED AT LINE 1429
                    > USED AT LINE 1132
                    > USED AT LINE 1431
                    > USED AT LINE 1474
L0534:              0534 DEFINED AT LINE 1430
                    > USED AT LINE 1435
L0543:              0543 DEFINED AT LINE 1438
                    > USED AT LINE 1439
L055E:              055E DEFINED AT LINE 1448
                    > USED AT LINE 1454
L057A:              057A DEFINED AT LINE 1475
                    > USED AT LINE 1470
L0586:              0586 DEFINED AT LINE 1490
                    > USED AT LINE 1480
                    > USED AT LINE 1501
L0594:              0594 DEFINED AT LINE 1497
                    > USED AT LINE 1492
L059D:              059D DEFINED AT LINE 1502
                    > USED AT LINE 1495
L05A0:              05A0 DEFINED AT LINE 1504
                    > USED AT LINE 1499
TAPEFAIL:           05A1 DEFINED AT LINE 1505
                    > USED AT LINE 1441
                    > USED AT LINE 1503
PF_ENTRY:           05B3 DEFINED AT LINE 1528
                    > USED AT LINE 264
                    > USED AT LINE 1505
                    > USED AT LINE 1515
                    > USED AT LINE 1518
L05BE:              05BD DEFINED AT LINE 1532
                    > USED AT LINE 1530
TAPE_DISP:          05C9 DEFINED AT LINE 1548
                    > USED AT LINE 1391
                    > USED AT LINE 1491
L05E1:              05E1 DEFINED AT LINE 1563
                    > USED AT LINE 1557
LOAD_BLK:           05E3 DEFINED AT LINE 1573
                    > USED AT LINE 1498
LOAD_BLK2:          05E7 DEFINED AT LINE 1575
                    > USED AT LINE 1440
L05E8:              05E8 DEFINED AT LINE 1576
                    > USED AT LINE 1584
L05F2:              05F2 DEFINED AT LINE 1582
                    > USED AT LINE 1592
L05F3:              05F3 DEFINED AT LINE 1583
                    > USED AT LINE 1599
L05FE:              05FE DEFINED AT LINE 1591
                    > USED AT LINE 1579
LOAD_BYTE:          060B DEFINED AT LINE 1603
                    > USED AT LINE 1577
                    > USED AT LINE 1586
L0610:              0610 DEFINED AT LINE 1605
                    > USED AT LINE 1608
LOAD_BIT:           0618 DEFINED AT LINE 1621
                    > USED AT LINE 1603
                    > USED AT LINE 1605
L061C:              061C DEFINED AT LINE 1623
                    > USED AT LINE 1628
                    > USED AT LINE 1631
L0627:              0627 DEFINED AT LINE 1629
                    > USED AT LINE 1624
READ_TAPE:          0630 DEFINED AT LINE 1639
                    > USED AT LINE 1430
                    > USED AT LINE 1438
                    > USED AT LINE 1623
L0633:              0633 DEFINED AT LINE 1640
                    > USED AT LINE 1643
L063C:              063C DEFINED AT LINE 1646
                    > USED AT LINE 1649
L064A:              064A DEFINED AT LINE 1660
                    > USED AT LINE 1666
TAPE_OUT:           064B DEFINED AT LINE 1661
                    > USED AT LINE 1362
                    > USED AT LINE 1412
SAVE_BYTE:          0657 DEFINED AT LINE 1674
                    > USED AT LINE 1664
L065D:              065D DEFINED AT LINE 1677
                    > USED AT LINE 1680
SAVE_BIT:           0666 DEFINED AT LINE 1691
                    > USED AT LINE 1676
                    > USED AT LINE 1678
L0674:              0674 DEFINED AT LINE 1698
                    > USED AT LINE 1693
L067B:              067B DEFINED AT LINE 1701
                    > USED AT LINE 1697
LOW_TONE:           0680 DEFINED AT LINE 1706
                    > USED AT LINE 1358
                    > USED AT LINE 1701
HIGH_TONE:          0684 DEFINED AT LINE 1710
                    > USED AT LINE 1364
                    > USED AT LINE 1409
                    > USED AT LINE 1418
                    > USED AT LINE 1695
                    > USED AT LINE 1699
L0686:              0686 DEFINED AT LINE 1714
                    > USED AT LINE 1707
L068E:              068E DEFINED AT LINE 1718
                    > USED AT LINE 1716
L0693:              0693 DEFINED AT LINE 1720
                    > USED AT LINE 1725
L0696:              0696 DEFINED AT LINE 1722
                    > USED AT LINE 1722
ERR_ENTRY:          069F DEFINED AT LINE 1730
                    > USED AT LINE 263
KEY_READ:           06AD DEFINED AT LINE 1754
                    > USED AT LINE 233
                    > USED AT LINE 1757
L06B5:              06B5 DEFINED AT LINE 1758
L06BA:              06BA DEFINED AT LINE 1761
                    > USED AT LINE 1767
L06BB:              06BB DEFINED AT LINE 1762
                    > USED AT LINE 1756
                    > USED AT LINE 1765
L06C1:              06C1 DEFINED AT LINE 1765
                    > USED AT LINE 1764
KEY_GET:            06CA DEFINED AT LINE 1770
                    > USED AT LINE 529
LCD_RESET:          06D5 DEFINED AT LINE 1785
                    > USED AT LINE 314
L06DB:              06DB DEFINED AT LINE 1787
                    > USED AT LINE 1793
L06DE:              06DE DEFINED AT LINE 1788
                    > USED AT LINE 1791
L06E7:              06E7 DEFINED AT LINE 1794
                    > USED AT LINE 1794
TAPE_JP_TBL:        0700 DEFINED AT LINE 1806
                    > USED AT LINE 1890
DEF_VARS:           070F DEFINED AT LINE 1818
                    > USED AT LINE 303
L0710:              0710 DEFINED AT LINE 1819
L0711:              0711 DEFINED AT LINE 1820
L0712:              0712 DEFINED AT LINE 1821
L0713:              0713 DEFINED AT LINE 1822
L0714:              0714 DEFINED AT LINE 1823
L0715:              0715 DEFINED AT LINE 1824
L0716:              0716 DEFINED AT LINE 1825
L0717:              0717 DEFINED AT LINE 1826
L0719:              0719 DEFINED AT LINE 1827
L071A:              071A DEFINED AT LINE 1828
L071B:              071B DEFINED AT LINE 1829
L071D:              071D DEFINED AT LINE 1830
L071F:              071F DEFINED AT LINE 1833
L0722:              0722 DEFINED AT LINE 1834
L0725:              0725 DEFINED AT LINE 1835
L0728:              0728 DEFINED AT LINE 1836
L072B:              072B DEFINED AT LINE 1837
L072E:              072E DEFINED AT LINE 1838
L0731:              0731 DEFINED AT LINE 1839
L0734:              0734 DEFINED AT LINE 1840
L0737:              0737 DEFINED AT LINE 1841
TAPE_AD_TBL:        073A DEFINED AT LINE 1845
                    > USED AT LINE 1891
L074E:              074E DEFINED AT LINE 1852
TAPE_ERRIN:         0752 DEFINED AT LINE 1853
                    > USED AT LINE 1730
TAPE_FAIL:          075C DEFINED AT LINE 1855
                    > USED AT LINE 1529
TAPE_DA_TBL:        0760 DEFINED AT LINE 1858
                    > USED AT LINE 1892
TAPE_FDA_TBL:       0768 DEFINED AT LINE 1863
                    > USED AT LINE 1528
L0772:              0772 DEFINED AT LINE 1870
TAPE_P_DRIVER:      077C DEFINED AT LINE 1874
                    > USED AT LINE 1026
TAPE_M_DRIVER:      0789 DEFINED AT LINE 1887
SEGREG_TBL:         0794 DEFINED AT LINE 1897
LCDFNC_TBL:         07AD DEFINED AT LINE 1913
                    > USED AT LINE 761
LCDRST_TBL:         07B5 DEFINED AT LINE 1918
                    > USED AT LINE 1785
L07B9:              07B9 DEFINED AT LINE 1925
LCDPMT_TBL:         07BD DEFINED AT LINE 1929
                    > USED AT LINE 734
PERM_DA_TBL:        07C6 DEFINED AT LINE 1933
                    > USED AT LINE 1876
SEG_TBL:            07D0 DEFINED AT LINE 1942
                    > USED AT LINE 579
                    > USED AT LINE 1550
L07E0:              07E0 DEFINED AT LINE 1948
                    > USED AT LINE 466
